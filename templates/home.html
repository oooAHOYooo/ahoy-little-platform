{% extends "base.html" %}

{% block title %}Ahoy Indie Media - Music Hub{% endblock %}

{% block content %}
<div class="home-page" x-data="homePage()" x-init="init()">
    <!-- Live Dashboard (TV & Radio) -->
    <section class="live-dashboard">
        <div class="dashboard-grid">
            <!-- Left: Main Feature (Live TV) -->
            <div class="dashboard-main"
                @click="tvCurrent && tvCurrent.id !== 'placeholder' && tvCurrent.id !== 'error' ? playShow(tvCurrent) : null">
                <div class="dash-preview">
                    <img
                        :src="tvCurrent?.thumbnail || '/static/img/default-cover.jpg'"
                        alt="Live TV" class="dash-bg">
                    <div class="dash-overlay">
                        <div class="dash-badges">
                            <span class="live-badge">LIVE TV</span>
                            <span class="channel-badge" x-text="tvCurrentChannel?.name || 'Channel 01 — Misc'"></span>
                        </div>
                        <!-- Channel Navigation -->
                        <div class="channel-nav" x-show="tvChannels.length > 1">
                            <button class="channel-nav-btn" 
                                    @click.stop="switchTVChannel('prev')"
                                    aria-label="Previous channel">
                                <i class="fas fa-chevron-left"></i>
                            </button>
                            <button class="channel-nav-btn" 
                                    @click.stop="switchTVChannel('next')"
                                    aria-label="Next channel">
                                <i class="fas fa-chevron-right"></i>
                            </button>
                        </div>
                        <div class="dash-content">
                            <h2 x-text="tvCurrent?.title || 'Loading...'"></h2>
                            <p
                                x-text="tvCurrent?.artist || tvCurrent?.host || ''"></p>
                            <div class="dash-actions">
                                <button class="dash-play-btn" 
                                        x-show="tvCurrent && tvCurrent.id !== 'placeholder' && tvCurrent.id !== 'error'"
                                        @click.stop="playShow(tvCurrent)">
                                    <i class="fas fa-play"></i> Watch Now
                                </button>
                                <a href="/live-tv" class="dash-guide-btn" @click.stop>
                                    <i class="fas fa-tv"></i> View All Channels
                                </a>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Right: Radio Feed -->
            <div class="dashboard-sidebar">
                <div class="sidebar-header">
                    <h3>Live Radio</h3>
                </div>

                <!-- Current Radio Track -->
                <div class="dash-item radio-item"
                    :class="{'active': radioIsPlaying}">
                    <div class="dash-thumb">
                        <img
                            :src="(radioCurrent || radioUpNext[0])?.cover_art || '/static/img/default-cover.jpg'"
                            alt="Radio">
                        <div class="dash-icon"><i
                                class="fas fa-broadcast-tower"></i></div>
                    </div>
                    <div class="dash-info">
                        <div class="dash-label">On Air Now</div>
                        <h4
                            x-text="(radioCurrent || radioUpNext[0])?.title || 'Loading...'"></h4>
                        <p
                            x-text="(radioCurrent || radioUpNext[0])?.artist || ''"></p>
                    </div>
                    <button class="dash-action-btn" @click.stop="toggleRadio()">
                        <i
                            :class="radioIsPlaying ? 'fas fa-pause' : 'fas fa-play'"></i>
                    </button>
                </div>

                <!-- Radio Up Next List -->
                <div class="radio-next-list">
                    <div class="list-label">Up Next</div>
                    <template x-for="track in radioUpNext.slice(0, 3)"
                        :key="track.id">
                        <div class="mini-track">
                            <span class="track-title"
                                x-text="track.title"></span>
                            <span class="track-artist"
                                x-text="track.artist"></span>
                        </div>
                    </template>
                </div>
            </div>
        </div>
    </section>

    <style>
    /* Live Dashboard Styles */
    .live-dashboard {
        margin-bottom: 2rem;
    }
    
    .dashboard-grid {
        display: grid;
        grid-template-columns: 1.6fr 1fr;
        gap: 1.5rem;
        /* Fixed height ensures alignment */
        height: 420px;
        min-height: 420px;
    }
    
    /* --- MAIN CARD (LEFT) --- */
    .dashboard-main {
        position: relative;
        border-radius: 24px;
        overflow: hidden;
        cursor: pointer;
        /* Subtle border for definition */
        border: 1px solid rgba(255, 255, 255, 0.08);
        background: #000;
        box-shadow: 0 20px 40px -10px rgba(0, 0, 0, 0.5);
        transition: transform 0.3s cubic-bezier(0.25, 0.8, 0.25, 1), border-color 0.3s;
    }
    
    .dashboard-main:hover {
        border-color: rgba(255, 255, 255, 0.2);
        transform: scale(1.005);
    }
    
    .dash-preview {
        height: 100%;
        width: 100%;
        position: relative;
    }
    
    .dash-bg {
        width: 100%;
        height: 100%;
        object-fit: cover;
        transition: transform 0.6s cubic-bezier(0.25, 0.8, 0.25, 1);
        opacity: 0.85;
    }
    
    .dashboard-main:hover .dash-bg {
        transform: scale(1.03);
        opacity: 0.6;
    }
    
    .dash-overlay {
        position: absolute;
        inset: 0;
        /* Better gradient for readability */
        background: linear-gradient(
            to top, 
            rgba(0,0,0,0.95) 0%, 
            rgba(0,0,0,0.6) 40%, 
            rgba(0,0,0,0.1) 100%
        );
        padding: 2.5rem;
        display: flex;
        flex-direction: column;
        justify-content: flex-end;
    }
    
    .dash-badges {
        position: absolute;
        top: 1.5rem;
        left: 1.5rem;
        display: flex;
        gap: 0.75rem;
        z-index: 2;
    }
    
    .channel-nav {
        position: absolute;
        top: 1.5rem;
        right: 1.5rem;
        display: flex;
        gap: 0.5rem;
        z-index: 2;
    }
    
    .channel-nav-btn {
        width: 36px;
        height: 36px;
        border-radius: 50%;
        background: rgba(0, 0, 0, 0.6);
        backdrop-filter: blur(12px);
        -webkit-backdrop-filter: blur(12px);
        border: 1px solid rgba(255, 255, 255, 0.2);
        color: white;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.2s;
        font-size: 0.875rem;
    }
    
    .channel-nav-btn:hover {
        background: rgba(0, 0, 0, 0.8);
        border-color: rgba(255, 255, 255, 0.4);
        transform: scale(1.1);
    }
    
    .live-badge {
        background: #ff0000;
        color: white;
        padding: 0.35rem 0.85rem;
        border-radius: 8px;
        font-weight: 800;
        font-size: 0.75rem;
        letter-spacing: 0.08em;
        box-shadow: 0 4px 12px rgba(255, 0, 0, 0.4);
        text-transform: uppercase;
    }
    
    .channel-badge {
        background: rgba(20, 20, 20, 0.75);
        backdrop-filter: blur(12px);
        -webkit-backdrop-filter: blur(12px);
        color: rgba(255, 255, 255, 0.9);
        padding: 0.35rem 0.85rem;
        border-radius: 8px;
        font-weight: 600;
        font-size: 0.75rem;
        border: 1px solid rgba(255, 255, 255, 0.1);
        letter-spacing: 0.02em;
    }
    
    .dash-content {
        position: relative;
        z-index: 2;
    }

    .dash-content h2 {
        font-size: 2.5rem;
        font-weight: 800;
        margin: 0 0 0.5rem 0;
        line-height: 1.1;
        letter-spacing: -0.02em;
        text-shadow: 0 2px 10px rgba(0,0,0,0.8);
        display: -webkit-box;
        -webkit-line-clamp: 2;
        -webkit-box-orient: vertical;
        overflow: hidden;
    }
    
    .dash-content p {
        font-size: 1.1rem;
        color: rgba(255, 255, 255, 0.8);
        margin: 0 0 1.75rem 0;
        font-weight: 500;
    }
    
    .dash-actions {
        display: flex;
        gap: 0.75rem;
        align-items: center;
        flex-wrap: wrap;
    }
    
    .dash-play-btn {
        background: white;
        color: black;
        border: none;
        padding: 0.85rem 1.75rem;
        border-radius: 99px;
        font-weight: 700;
        font-size: 0.95rem;
        display: inline-flex;
        align-items: center;
        gap: 0.6rem;
        cursor: pointer;
        transition: all 0.2s;
        box-shadow: 0 4px 20px rgba(255, 255, 255, 0.2);
        text-decoration: none;
    }
    
    .dash-play-btn:hover {
        background: #f0f0f0;
        transform: translateY(-2px);
        box-shadow: 0 8px 25px rgba(255, 255, 255, 0.3);
    }
    
    .dash-guide-btn {
        background: rgba(255, 255, 255, 0.1);
        color: white;
        border: 1px solid rgba(255, 255, 255, 0.2);
        padding: 0.85rem 1.75rem;
        border-radius: 99px;
        font-weight: 700;
        font-size: 0.95rem;
        display: inline-flex;
        align-items: center;
        gap: 0.6rem;
        cursor: pointer;
        transition: all 0.2s;
        text-decoration: none;
        backdrop-filter: blur(12px);
        -webkit-backdrop-filter: blur(12px);
    }
    
    .dash-guide-btn:hover {
        background: rgba(255, 255, 255, 0.2);
        border-color: rgba(255, 255, 255, 0.3);
        transform: translateY(-2px);
    }
    
    /* --- SIDEBAR (RIGHT) --- */
    .dashboard-sidebar {
        display: flex;
        flex-direction: column;
        gap: 1rem;
        /* Clean glass panel */
        background: rgba(20, 20, 20, 0.6);
        backdrop-filter: blur(20px);
        -webkit-backdrop-filter: blur(20px);
        border-radius: 24px;
        border: 1px solid rgba(255, 255, 255, 0.08);
        padding: 1.5rem;
        height: 100%;
    }
    
    .sidebar-header {
        border-bottom: 1px solid rgba(255, 255, 255, 0.08);
        padding-bottom: 1rem;
        margin-bottom: 0.5rem;
    }

    .sidebar-header h3 {
        font-size: 0.75rem;
        text-transform: uppercase;
        letter-spacing: 0.15em;
        color: rgba(255, 255, 255, 0.5);
        margin: 0;
        font-weight: 700;
    }
    
    /* Card Items in Sidebar */
    .dash-item {
        display: flex;
        align-items: center;
        gap: 1.25rem;
        padding: 1rem;
        border-radius: 16px;
        background: rgba(255, 255, 255, 0.03);
        border: 1px solid rgba(255, 255, 255, 0.05);
        transition: all 0.2s ease;
        position: relative;
        overflow: hidden;
    }
    
    .dash-item:hover {
        background: rgba(255, 255, 255, 0.08);
        border-color: rgba(255, 255, 255, 0.1);
        transform: translateX(4px);
    }
    
    .dash-item.active {
        background: rgba(99, 102, 241, 0.15); /* Accent color tint */
        border-color: rgba(99, 102, 241, 0.3);
    }
    
    .dash-thumb {
        width: 72px;
        height: 72px;
        border-radius: 12px;
        overflow: hidden;
        position: relative;
        flex-shrink: 0;
        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    }
    
    .dash-thumb img {
        width: 100%;
        height: 100%;
        object-fit: cover;
        transition: transform 0.3s;
    }
    
    .dash-item:hover .dash-thumb img {
        transform: scale(1.1);
    }
    
    .dash-icon {
        position: absolute;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(0,0,0,0.4);
        opacity: 0; /* Hidden by default */
        transition: opacity 0.2s;
    }
    
    /* Show icon on hover or if active (for radio) */
    .dash-item:hover .dash-icon,
    .dash-item.active .dash-icon {
        opacity: 1;
    }
    
    .dash-icon i {
        font-size: 1.2rem;
        color: white;
        filter: drop-shadow(0 2px 4px rgba(0,0,0,0.5));
    }
    
    .dash-info {
        flex: 1;
        min-width: 0;
        display: flex;
        flex-direction: column;
        justify-content: center;
    }
    
    .dash-label {
        font-size: 0.65rem;
        color: var(--accent-color, #6366f1);
        text-transform: uppercase;
        font-weight: 800;
        letter-spacing: 0.05em;
        margin-bottom: 0.35rem;
    }
    
    .dash-info h4 {
        margin: 0 0 0.25rem 0;
        font-size: 1.1rem;
        font-weight: 700;
        line-height: 1.2;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        color: #fff;
    }
    
    .dash-info p {
        margin: 0;
        font-size: 0.9rem;
        color: rgba(255, 255, 255, 0.6);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        font-weight: 500;
    }
    
    .dash-action-btn {
        width: 42px;
        height: 42px;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.1);
        color: white;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.2s;
        flex-shrink: 0;
    }
    
    .dash-action-btn:hover {
        background: white;
        color: black;
        transform: scale(1.1);
    }
    
    /* Radio Up Next List */
    .radio-next-list {
        margin-top: auto;
        padding-top: 1rem;
    }
    
    .list-label {
        font-size: 0.7rem;
        text-transform: uppercase;
        letter-spacing: 0.1em;
        color: rgba(255, 255, 255, 0.4);
        margin-bottom: 0.75rem;
        font-weight: 600;
    }
    
    .mini-track {
        display: flex;
        gap: 0.5rem;
        padding: 0.5rem 0;
        border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        font-size: 0.85rem;
    }
    
    .mini-track:last-child {
        border-bottom: none;
    }
    
    .track-title {
        color: rgba(255, 255, 255, 0.9);
        font-weight: 500;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        flex: 1;
    }
    
    .track-artist {
        color: rgba(255, 255, 255, 0.5);
        max-width: 40%;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        text-align: right;
    }

    /* Mobile Responsive */
    @media (max-width: 900px) {
        .dashboard-grid {
            grid-template-columns: 1fr;
            height: auto;
            gap: 1rem;
        }
        .dashboard-main {
            aspect-ratio: 4/3;
            min-height: 300px;
        }
        .dashboard-sidebar {
            padding: 1rem;
            height: auto;
        }
        .dash-content h2 {
            font-size: 1.75rem;
        }
        .dash-overlay {
            padding: 1.5rem;
        }
        .dash-actions {
            flex-direction: column;
            align-items: stretch;
        }
        .dash-play-btn,
        .dash-guide-btn {
            width: 100%;
            justify-content: center;
        }
    }
    </style>

    <!-- What's New at Ahoy Section -->
    <section class="whats-new-section" x-data="whatsNew()" x-init="loadUpdates()">
        <div class="whats-new-container">
            <div class="whats-new-header">
                <h2><i class="fas fa-bullhorn"></i> What's New at Ahoy</h2>
            </div>
            <div x-show="isLoading" class="whats-new-loading">
                <span>Loading updates...</span>
            </div>
            <div x-show="!isLoading && updates.length > 0" class="whats-new-updates">
                <template x-for="update in updates" :key="update.id">
                    <div class="whats-new-item" :class="'type-' + (update.type || 'update')">
                        <div class="whats-new-icon">
                            <i :class="update.icon || 'fas fa-info-circle'"></i>
                        </div>
                        <div class="whats-new-content">
                            <h3 x-text="update.title"></h3>
                            <p x-text="update.description"></p>
                            <span class="whats-new-date" x-text="formatDate(update.date)"></span>
                        </div>
                    </div>
                </template>
            </div>
            <div x-show="!isLoading && updates.length === 0" class="whats-new-empty">
                <p>No updates available at this time.</p>
            </div>
        </div>
    </section>

    <style>
    /* What's New Section Styles */
    .whats-new-section {
        margin: 2rem 0;
        padding: 0;
    }

    .whats-new-container {
        background: rgba(20, 20, 20, 0.6);
        backdrop-filter: blur(20px);
        -webkit-backdrop-filter: blur(20px);
        border-radius: 24px;
        border: 1px solid rgba(255, 255, 255, 0.08);
        padding: 2rem;
    }

    .whats-new-header {
        margin-bottom: 1.5rem;
        border-bottom: 1px solid rgba(255, 255, 255, 0.08);
        padding-bottom: 1rem;
    }

    .whats-new-header h2 {
        font-size: 1.5rem;
        font-weight: 700;
        margin: 0;
        color: #fff;
        display: flex;
        align-items: center;
        gap: 0.75rem;
    }

    .whats-new-header h2 i {
        color: var(--accent-color, #6366f1);
    }

    .whats-new-loading,
    .whats-new-empty {
        text-align: center;
        padding: 2rem;
        color: rgba(255, 255, 255, 0.5);
    }

    .whats-new-updates {
        display: flex;
        flex-direction: column;
        gap: 1rem;
    }

    .whats-new-item {
        display: flex;
        gap: 1rem;
        padding: 1.25rem;
        background: rgba(255, 255, 255, 0.03);
        border: 1px solid rgba(255, 255, 255, 0.05);
        border-radius: 16px;
        transition: all 0.2s ease;
    }

    .whats-new-item:hover {
        background: rgba(255, 255, 255, 0.08);
        border-color: rgba(255, 255, 255, 0.1);
        transform: translateX(4px);
    }

    .whats-new-item.type-feature {
        border-left: 3px solid #6366f1;
    }

    .whats-new-item.type-improvement {
        border-left: 3px solid #10b981;
    }

    .whats-new-item.type-content {
        border-left: 3px solid #f59e0b;
    }

    .whats-new-icon {
        width: 48px;
        height: 48px;
        border-radius: 12px;
        background: rgba(99, 102, 241, 0.15);
        display: flex;
        align-items: center;
        justify-content: center;
        flex-shrink: 0;
        color: #6366f1;
        font-size: 1.25rem;
    }

    .whats-new-content {
        flex: 1;
        min-width: 0;
    }

    .whats-new-content h3 {
        font-size: 1.1rem;
        font-weight: 700;
        margin: 0 0 0.5rem 0;
        color: #fff;
    }

    .whats-new-content p {
        font-size: 0.9rem;
        color: rgba(255, 255, 255, 0.7);
        margin: 0 0 0.5rem 0;
        line-height: 1.5;
    }

    .whats-new-date {
        font-size: 0.75rem;
        color: rgba(255, 255, 255, 0.4);
        text-transform: uppercase;
        letter-spacing: 0.05em;
    }

    /* Mobile Responsive */
    @media (max-width: 768px) {
        .whats-new-container {
            padding: 1.25rem;
            border-radius: 16px;
        }

        .whats-new-header h2 {
            font-size: 1.25rem;
        }

        .whats-new-item {
            padding: 1rem;
            gap: 0.75rem;
        }

        .whats-new-icon {
            width: 40px;
            height: 40px;
            font-size: 1rem;
        }

        .whats-new-content h3 {
            font-size: 1rem;
        }

        .whats-new-content p {
            font-size: 0.85rem;
        }
    }
    </style>

    <!-- Compact Discovery Grid -->
    <section class="discovery-grid">
        <div class="grid-container">

            <!-- Live TV Now (Thumbnail Gallery) -->
            <div class="grid-item live-tv-now">
                <div class="item-header">
                    <h3><i class="fas fa-tv"></i> Live TV Now</h3>
                    <a href="/live-tv" class="view-all-btn">Channel Guide</a>
                </div>
                <div class="playing-list">
                    <template x-for="(show, index) in featuredShows.slice(0, 1)"
                        :key="show.id">
                        <div class="playing-item"
                            x-show="show.thumbnail"
                            style="min-height: 180px; border-radius: 12px; overflow: hidden; position: relative; cursor: pointer;"
                            :style="`background-image: url(${show.thumbnail}); background-size: cover; background-position: center;`"
                            @click="playShow(show, index)">

                            <div class="hero-overlay"
                                style="background: linear-gradient(to top, rgba(0,0,0,0.9), transparent);">
                                <div class="hero-content"
                                    style="position: absolute; bottom: 0; left: 0; right: 0; padding: 1rem;">
                                    <div class="hero-badge"
                                        style="background: #ff0000; color: white; display: inline-block; padding: 2px 6px; border-radius: 4px; font-size: 0.7rem; margin-bottom: 0.5rem;">LIVE</div>
                                    <h3 x-text="show.title"
                                        style="margin: 0; font-size: 1.1rem; color: white;"></h3>
                                    <p x-text="show.host"
                                        style="margin: 0; font-size: 0.9rem; color: rgba(255,255,255,0.8);"></p>
                                </div>
                                <div class="play-indicator"
                                    style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.5); border-radius: 50%; width: 48px; height: 48px; display: flex; align-items: center; justify-content: center; border: 2px solid rgba(255,255,255,0.8);">
                                    <i class="fas fa-play"
                                        style="color: white; font-size: 1.2rem; margin-left: 4px;"></i>
                                </div>
                            </div>
                        </div>
                    </template>
                    <div x-show="!featuredShows || featuredShows.length === 0"
                        style="padding: 2rem; text-align: center; color: rgba(255,255,255,0.5);">
                        No live shows currently airing.
                    </div>
                </div>
            </div>

            <!-- Now Playing Compact (Radio Feed) -->
            <div class="grid-item now-playing-compact">
                <div class="item-header">
                    <h3>Radio Feed</h3>
                    <a href="/radio" class="view-all-btn">Full Radio</a>
                </div>
                <!-- Radio Feed fills entire container -->
                <a href="/radio" class="radio-feed-single"
                    :style="`--radio-bg-image: url(${(radioCurrent || radioUpNext[0])?.cover_art || '/static/img/default-cover.jpg'});`">
                    <!-- Track Info -->
                    <div class="radio-feed-content">
                        <div class="radio-feed-title"
                            x-text="(radioCurrent || radioUpNext[0])?.title || 'No track playing'"></div>
                        <div class="radio-feed-artist"
                            x-text="(radioCurrent || radioUpNext[0])?.artist || ''"></div>
                    </div>

                    <!-- Placeholder if no tracks -->
                    <div x-show="!radioCurrent && radioUpNext.length === 0"
                        class="radio-feed-loading">
                        <span>Loading radio feed...</span>
                    </div>
                </a>
            </div>

            <!-- Live Shows Compact -->
            <div class="grid-item shows-compact">
                <div class="item-header">
                    <h3><i class="fas fa-play-circle"></i> Live Now</h3>
                    <a href="/shows" class="view-all-btn">All</a>
                </div>
                <div class="playing-list">
                    <template x-for="(show, index) in featuredShows.slice(0, 4)"
                        :key="show.id">
                        <div class="playing-item"
                            x-show="show.thumbnail"
                            :class="{'playing': currentShowIndex === index}"
                            :style="`background-image: linear-gradient(rgba(0,0,0,0.6), rgba(0,0,0,0.8)), url(${show.thumbnail}); background-size: cover; background-position: center;`"
                            @click="playShow(show, index)">
                            <div class="item-details">
                                <h4 x-text="show.title"></h4>
                                <p x-text="show.host"></p>
                            </div>
                            <div class="play-indicator"
                                x-show="currentShowIndex === index">
                                <i class="fas fa-play"></i>
                            </div>
                        </div>
                    </template>
                </div>
            </div>

            <!-- Recently Added (Latest Updates) -->
            <div class="grid-item recently-added" x-data="recentlyAdded()"
                x-init="init()">
                <div class="item-header">
                    <h3><i class="fas fa-bolt"></i> Recently Added</h3>
                    <span class="view-all-btn" x-show="latestDateText"
                        x-text="latestDateText"></span>
                </div>
                <div x-show="isLoading" class="playing-list">
                    <div class="playing-item"
                        style="opacity:.6;display:flex;align-items:center;justify-content:center;">
                        <span>Loading latest…</span>
                    </div>
                </div>
                <div class="playing-list recently-added-grid">
                    <template x-for="item in latestItems" :key="item.id">
                        <div class="playing-item"
                            x-show="item.cover_art || item.thumbnail"
                            :style="`background-image: linear-gradient(rgba(0,0,0,0.6), rgba(0,0,0,0.8)), url(${item.cover_art || item.thumbnail}); background-size: cover; background-position: center;`"
                            @click="play(item)">
                            <div class="item-details">
                                <h4 x-text="item.title"></h4>
                                <p
                                    x-text="item.artist || (item.host || '')"></p>
                            </div>
                            <div class="play-indicator">
                                <i class="fas fa-play"></i>
                            </div>
                        </div>
                    </template>
                </div>
            </div>
        </div>
    </section>

    <!-- Loading State -->
    <section x-show="isLoading" class="loading-section">
        <div class="spinner"></div>
        <p>Loading awesome content...</p>
    </section>

    <!-- Mobile Widget Stack (at bottom of homepage) -->
    <section class="mobile-widget-stack mobile-only" style="margin-top:12px;">
        <!-- Boost -->
        <div class="widget boost-widget" style="padding:12px;">
            <div class="body-mobile"
                style="display:flex;align-items:center;justify-content:space-between;gap:10px;">
                <div class="label-mobile">Boost an Artist</div>
                <button class="mobile-hamburger" title="Boost"
                    @click="document.dispatchEvent(new CustomEvent('boost:open'))">
                    <i class="fas fa-bolt"></i>
                </button>
            </div>
        </div>

        <!-- Radio Now -->
        <div class="widget radio-widget" style="padding:12px;">
            <div class="label-mobile" style="margin-bottom:6px;">Radio Now</div>
            <div style="display:flex;align-items:center;gap:10px;">
                <div style="flex:1;min-width:0;">
                    <div class="body-mobile"
                        x-text="(radioCurrent || radioUpNext[0])?.title || 'No track playing'"></div>
                    <div style="opacity:.7;font-size:.8rem;"
                        x-text="(radioCurrent || radioUpNext[0])?.artist || ''"></div>
                </div>
                <button class="mobile-hamburger" @click="toggleRadio()"
                    :title="radioIsPlaying ? 'Pause' : 'Play'">
                    <i
                        :class="radioIsPlaying ? 'fas fa-pause' : 'fas fa-play'"></i>
                </button>
            </div>
        </div>

        <!-- Live Now (Shows) -->
        <div class="widget live-now-widget" style="padding:12px;">
            <div class="label-mobile" style="margin-bottom:6px;">Live Now</div>
            <template x-if="featuredShows && featuredShows.length">
                <div
                    style="display:flex;gap:10px;align-items:center;cursor:pointer;"
                    @click="playShow(featuredShows[0], 0)">
                    <div
                        style="width:56px;height:56px;border-radius:8px;background-size:cover;background-position:center;"
                        :style="`background-image:url(${featuredShows[0]?.thumbnail || '/static/img/default-cover.jpg'})`"></div>
                    <div style="flex:1;min-width:0;">
                        <div class="body-mobile"
                            x-text="featuredShows[0]?.title || 'Show'"></div>
                        <div style="opacity:.7;font-size:.8rem;"
                            x-text="featuredShows[0]?.host || ''"></div>
                    </div>
                    <i class="fas fa-play"></i>
                </div>
            </template>
            <div x-show="!featuredShows || featuredShows.length===0"
                style="opacity:.6;">Loading…</div>
        </div>

        <!-- Recently Added -->
        <div class="widget recently-added-widget" x-data="recentlyAdded()"
            x-init="init()" style="padding:10px;">
            <div class="label-mobile" style="margin-bottom:6px;">Recently
                Added</div>
            <div style="display:flex;gap:6px;overflow:auto;">
                <template x-for="item in latestItems.slice(0, 8)"
                    :key="item.id">
                    <div
                        style="min-width:96px;border-radius:10px;overflow:hidden;background:#111;border:1px solid #222;cursor:pointer;"
                        @click="play(item)">
                        <div
                            style="width:100%;height:56px;background-size:cover;background-position:center;"
                            :style="`background-image:url(${item.cover_art || item.thumbnail || '/static/img/default-cover.jpg'})`"></div>
                        <div style="padding:6px;">
                            <div
                                style="font-size:.78rem;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;"
                                x-text="item.title"></div>
                            <div
                                style="opacity:.7;font-size:.68rem;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;"
                                x-text="item.artist || ''"></div>
                        </div>
                    </div>
                </template>
            </div>
        </div>

        <!-- Bookmarks -->
        <div class="widget bookmark-widget" x-data="homeBookmarksWidget()"
            x-init="loadBookmarks()" style="padding:12px;">
            <div class="label-mobile" style="margin-bottom:6px;">Your
                Bookmarks</div>
            <div style="display:flex;gap:8px;overflow:auto;">
                <template x-for="b in bookmarksList().slice(0, 8)" :key="b.key">
                    <button @click="playBookmark(b)"
                        style="display:flex;gap:8px;align-items:center;min-width:160px;border-radius:10px;background:#111;border:1px solid #222;padding:8px 10px;color:inherit;text-align:left;">
                        <div
                            style="width:40px;height:40px;border-radius:8px;background-size:cover;background-position:center;"
                            :style="`background-image:url(${b.cover_art || b.thumbnail || '/static/img/default-cover.jpg'})`"></div>
                        <div style="flex:1;min-width:0;">
                            <div
                                style="font-size:.85rem;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;"
                                x-text="b.title"></div>
                            <div
                                style="opacity:.7;font-size:.75rem;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;"
                                x-text="b.artist || ''"></div>
                        </div>
                    </button>
                </template>
            </div>
        </div>
    </section>

    <!-- Create Account Modal -->
    <div x-show="showCreateAccountModal" class="modal-overlay"
        @click="closeCreateAccountModal()">
        <div class="modal-content create-account-modal" @click.stop>
            <div class="modal-header">
                <h3>Save Your Work</h3>
                <button @click="closeCreateAccountModal()"
                    class="close-btn">&times;</button>
            </div>
            <div class="modal-body">
                <div class="save-warning-icon">
                    <i class="fas fa-exclamation-triangle"></i>
                </div>
                <h4>Don't Lose Your Work!</h4>
                <p>You're creating playlists and saving content, but without an
                    account, your work will be lost when you leave this
                    page.</p>
                <div class="benefits-list">
                    <div class="benefit-item">
                        <i class="fas fa-check"></i>
                        <span>Save playlists permanently</span>
                    </div>
                    <div class="benefit-item">
                        <i class="fas fa-check"></i>
                        <span>Access your content anywhere</span>
                    </div>
                    <div class="benefit-item">
                        <i class="fas fa-check"></i>
                        <span>Sync across devices</span>
                    </div>
                    <div class="benefit-item">
                        <i class="fas fa-check"></i>
                        <span>Get personalized recommendations</span>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button @click="closeCreateAccountModal()"
                    class="btn btn-secondary">Continue as Guest</button>
                <button @click="goToAuth()" class="btn btn-primary">
                    <i class="fas fa-user-plus"></i> Create Free Account
                </button>
            </div>
        </div>
    </div>
</div>

<!-- Left Dashboard and adjustments -->
<div class="left-dashboard" style="display: flex; flex-direction: column;">
    <!-- Merit Badges with subtle border and tiny icons -->
    <div class="merit-badges"
        style="border: 1px solid rgba(255, 255, 255, 0.05); margin-bottom: 1rem; max-height: 100px; overflow-y: auto; display: flex;">
        <div class="badge"
            style="flex: 1; margin: 0 5px; display: flex; align-items: center; justify-content: center;">
            <!-- Small icon for badge -->
            <i class="fas fa-medal" style="font-size: 0.75rem;"></i>
        </div>
        <!-- Repeat for more badges -->
    </div>

    <!-- (Removed legacy media players to avoid duplication with global Now Playing bar) -->
</div>

<script>
function homePage() {
    return {
        // State
        isLoading: true,
        feedItems: [],
        featuredArtist: null,
        featuredShows: [],
        heroItems: [],
        currentIndex: 0,
        currentShowIndex: 0,
        currentHeroIndex: 0,
        heroOffset: 0,
        heroInterval: null,
        touchStartX: 0,
        touchStartY: 0,
        isDragging: false,
        userPlaylists: [],
        hasUnsavedWork: false,
        showCreateAccountModal: false,
        newPlaylistName: '',
        newPlaylistDescription: '',
        showPlaylistForm: false,
        
        // Radio state
        radioTracks: [],
        radioQueue: [],
        radioPrevious: null,
        radioCurrent: null,
        radioUpNext: [],
        radioIsPlaying: false,
        radioShuffle: true,
        tvCurrent: null,
        tvNext: null,
        tvChannels: [],
        tvCurrentChannel: null,
        tvChannelIndex: 0,
        
        // Initialize
        async init() {
            await this.loadAllData();
            this.isLoading = false;
            // this.startHeroRotation(); // Disabled hero rotation for dashboard layout
            
            // Sync playing state with media player if available
            this.syncPlayingState();
            
            // Load radio feed
            await this.loadRadioFeed();
            
            // Load TV status
            await this.loadTVStatus();
            
            // Set up radio sync with media player
            this.setupRadioSync();
            
            // Load user playlists if logged in
            if (window.ahoyApp && window.ahoyApp.isLoggedIn) {
                await this.loadUserPlaylists();
            }
            
            // Set up save warning system
            this.setupSaveWarning();
            
            // Add resize listener to recalculate hero offset
            window.addEventListener('resize', () => {
                this.updateHeroOffset();
            });
            
            // Expose functions globally for keyplaylist navigation
            window.homePage = this;
        },
        
        syncPlayingState() {
            // Check if media player has a current track and sync the index
            if (window.mediaPlayer && window.mediaPlayer.currentTrack && this.feedItems.length > 0) {
                const currentTrack = window.mediaPlayer.currentTrack;
                const displayedItems = this.feedItems.slice(0, 4);
                const foundIndex = displayedItems.findIndex(i => {
                    const itemId = i.id || i.track_id || i.show_id;
                    const currentId = currentTrack.id || currentTrack.track_id;
                    return itemId && currentId && String(itemId) === String(currentId);
                });
                if (foundIndex !== -1) {
                    this.currentIndex = foundIndex;
                }
            }
        },
        
        // Data loading
        async loadAllData() {
            try {
                await Promise.all([
                    this.loadNowPlaying(),
                    this.loadFeaturedArtist(),
                    this.loadFeaturedShows()
                ]);
                this.prepareHeroItems();
            } catch (error) {
                console.error('Error loading data:', error);
            }
        },
        
        async loadNowPlaying() {
            try {
                // Use shared data store to prevent duplicate calls
                const data = window.__ahoyDataStore ? 
                    await window.__ahoyDataStore.getNowPlaying() :
                    await (await fetch('/api/now-playing')).json();
                // Normalize feed items - API returns type: 'music' but we need type: 'track' for mediaPlayer
                this.feedItems = (data.feed || []).map(item => ({
                    ...item,
                    type: item.type === 'music' ? 'track' : item.type,
                    audio_url: item.audio_url || item.preview_url || item.full_url
                }));
                // Re-sync playing state after loading feed items
                this.syncPlayingState();
            } catch (error) {
                console.error('Error loading now playing:', error);
            }
        },
        
        async loadFeaturedArtist() {
            try {
                // Use shared data store to prevent duplicate calls
                const data = window.__ahoyDataStore ? 
                    await window.__ahoyDataStore.getArtists() :
                    await (await fetch('/api/artists')).json();
                const artists = data.artists || [];
                this.featuredArtist = artists[Math.floor(Math.random() * artists.length)];
            } catch (error) {
                console.error('Error loading featured artist:', error);
            }
        },
        
        async loadFeaturedShows() {
            try {
                // Use shared data store to prevent duplicate calls
                const data = window.__ahoyDataStore ? 
                    await window.__ahoyDataStore.getShows() :
                    await (await fetch('/api/shows')).json();
                const shows = data.shows || [];
                this.featuredShows = shows.sort(() => 0.5 - Math.random()).slice(0, 3);
            } catch (error) {
                console.error('Error loading featured shows:', error);
            }
        },
        
        prepareHeroItems() {
            // Mix music and shows for hero feed
            const musicItems = this.feedItems.slice(0, 4);
            const showItems = this.featuredShows.slice(0, 2);
            this.heroItems = [...musicItems, ...showItems].sort(() => 0.5 - Math.random());
            
            // Calculate initial hero offset after items are set
            setTimeout(() => {
                this.updateHeroOffset();
            }, 100);
        },
        
        startHeroRotation() {
            this.heroInterval = setInterval(() => {
                this.nextHero();
            }, 5000); // Change every 5 seconds
        },
        
        stopHeroRotation() {
            if (this.heroInterval) {
                clearInterval(this.heroInterval);
                this.heroInterval = null;
            }
        },
        
        // TV Status
        async loadTVStatus() {
            try {
                const response = await fetch('/api/live-tv/channels');
                const data = await response.json();
                const channels = data.channels || [];
                this.tvChannels = channels;
                
                // Map channel IDs to display names
                const channelNames = {
                    'misc': 'Channel 01 — Misc',
                    'films': 'Channel 02 — Short Films',
                    'music-videos': 'Channel 03 — Music Videos',
                    'live-shows': 'Channel 04 — Live Shows'
                };
                
                // Default to Channel 1 (Misc) or first available channel
                if (channels.length > 0) {
                    // Find Misc channel first, or use first channel
                    let ch = channels.find(c => c.id === 'misc') || channels[0];
                    this.tvChannelIndex = channels.findIndex(c => c.id === ch.id);
                    
                    this.tvCurrentChannel = {
                        ...ch,
                        name: channelNames[ch.id] || `Channel ${String(this.tvChannelIndex + 1).padStart(2, '0')} — ${ch.name || 'Unknown'}`
                    };
                    
                    if (ch.items && ch.items.length > 0) {
                        // Get current item based on time (simple rotation)
                        // Use hour of day to determine which item to show
                        const hour = new Date().getHours();
                        const itemIndex = hour % ch.items.length;
                        this.tvCurrent = ch.items[itemIndex];
                        this.tvNext = ch.items.length > itemIndex + 1 ? ch.items[itemIndex + 1] : ch.items[0];
                    } else {
                        // If no items, still show the channel but with placeholder
                        this.tvCurrent = {
                            id: 'placeholder',
                            title: 'No content available',
                            thumbnail: '/static/img/default-cover.jpg',
                            host: ch.name
                        };
                    }
                } else {
                    // Fallback if no channels
                    this.tvCurrent = {
                        id: 'placeholder',
                        title: 'Loading Live TV...',
                        thumbnail: '/static/img/default-cover.jpg',
                        host: 'Ahoy TV'
                    };
                    this.tvCurrentChannel = {
                        id: 'misc',
                        name: 'Channel 01 — Misc'
                    };
                }
            } catch (error) {
                console.error('Error loading TV status:', error);
                // Fallback on error
                this.tvCurrent = {
                    id: 'error',
                    title: 'Live TV',
                    thumbnail: '/static/img/default-cover.jpg',
                    host: 'Ahoy TV'
                };
                this.tvCurrentChannel = {
                    id: 'misc',
                    name: 'Channel 01 — Misc'
                };
            }
        },
        
        // Switch TV Channel
        switchTVChannel(direction) {
            if (this.tvChannels.length === 0) return;
            
            if (direction === 'next') {
                this.tvChannelIndex = (this.tvChannelIndex + 1) % this.tvChannels.length;
            } else if (direction === 'prev') {
                this.tvChannelIndex = (this.tvChannelIndex - 1 + this.tvChannels.length) % this.tvChannels.length;
            }
            
            const ch = this.tvChannels[this.tvChannelIndex];
            const channelNames = {
                'misc': 'Channel 01 — Misc',
                'films': 'Channel 02 — Short Films',
                'music-videos': 'Channel 03 — Music Videos',
                'live-shows': 'Channel 04 — Live Shows'
            };
            
            this.tvCurrentChannel = {
                ...ch,
                name: channelNames[ch.id] || `Channel ${String(this.tvChannelIndex + 1).padStart(2, '0')} — ${ch.name || 'Unknown'}`
            };
            
            if (ch.items && ch.items.length > 0) {
                const hour = new Date().getHours();
                const itemIndex = hour % ch.items.length;
                this.tvCurrent = ch.items[itemIndex];
                this.tvNext = ch.items.length > itemIndex + 1 ? ch.items[itemIndex + 1] : ch.items[0];
            }
        },

        // Hero navigation
        nextHero() {
            if (this.currentHeroIndex < this.heroItems.length - 1) {
                this.currentHeroIndex++;
            } else {
                this.currentHeroIndex = 0;
            }
            this.updateHeroOffset();
        },
        
        prevHero() {
            if (this.currentHeroIndex > 0) {
                this.currentHeroIndex--;
            } else {
                this.currentHeroIndex = this.heroItems.length - 1;
            }
            this.updateHeroOffset();
        },
        
        setHeroIndex(index) {
            this.currentHeroIndex = index;
            this.updateHeroOffset();
        },
        
        updateHeroOffset() {
            // Get the width of the hero container to calculate proper offset
            const heroContainer = document.querySelector('.tv-hero');
            if (heroContainer) {
                const containerWidth = heroContainer.offsetWidth;
                this.heroOffset = -this.currentHeroIndex * containerWidth;
            } else {
                // Fallback to 100% if container not found
                this.heroOffset = -this.currentHeroIndex * 100;
            }
        },
        
        // Touch handling for mobile swipe
        handleTouchStart(event) {
            this.touchStartX = event.touches[0].clientX;
            this.touchStartY = event.touches[0].clientY;
            this.isDragging = false;
            this.stopHeroRotation();
        },
        
        handleTouchMove(event) {
            if (!this.touchStartX) return;
            
            const touchX = event.touches[0].clientX;
            const touchY = event.touches[0].clientY;
            const diffX = this.touchStartX - touchX;
            const diffY = this.touchStartY - touchY;
            
            // Only consider it a drag if horizontal movement is greater than vertical
            if (Math.abs(diffX) > Math.abs(diffY)) {
                this.isDragging = true;
                event.preventDefault();
            }
        },
        
        handleTouchEnd(event) {
            if (!this.isDragging || !this.touchStartX) {
                this.startHeroRotation();
                return;
            }
            
            const touchX = event.changedTouches[0].clientX;
            const diffX = this.touchStartX - touchX;
            const threshold = 50; // Minimum swipe distance
            
            if (Math.abs(diffX) > threshold) {
                if (diffX > 0) {
                    // Swiped left - go to next
                    this.nextHero();
                } else {
                    // Swiped right - go to previous
                    this.prevHero();
                }
            }
            
            this.touchStartX = 0;
            this.touchStartY = 0;
            this.isDragging = false;
            this.startHeroRotation();
        },
        
        // Actions
        playRandom() {
            if (this.feedItems.length > 0) {
                // Get the displayed items (first 4)
                const displayedItems = this.feedItems.slice(0, 4);
                const randomIndex = Math.floor(Math.random() * displayedItems.length);
                this.playItem(displayedItems[randomIndex], randomIndex);
            }
        },
        
        playItem(item, index) {
            // Update current index for visual feedback
            this.currentIndex = index;
            this.stopHeroRotation();
            
            // Ensure item has required properties
            const normalizedItem = {
                ...item,
                type: item.type || (item.host || item.show_id ? 'show' : 'track'),
                id: item.id || item.track_id || item.show_id
            };
            
            console.log('🎵 Playing item:', normalizedItem);
            
            // Determine if it's a show or track
            const isShow = normalizedItem.type === 'show' || normalizedItem.host || normalizedItem.show_id || normalizedItem.video_url || normalizedItem.mp4_link;
            
            if (isShow) {
                // For shows, navigate to player page
                console.log('🎵 Playing show, navigating to player');
                window.location.href = `/player?id=${normalizedItem.id}&type=show`;
                return;
            }
            
            // For music tracks, try to play with media player
            if (window.mediaPlayer && typeof window.mediaPlayer.play === 'function') {
                // Ensure the item has proper structure for mediaPlayer
                const playItem = {
                    ...normalizedItem,
                    type: 'track',
                    audio_url: normalizedItem.audio_url || normalizedItem.preview_url || normalizedItem.full_url,
                    cover_art: normalizedItem.cover_art || normalizedItem.thumbnail,
                    title: normalizedItem.title,
                    artist: normalizedItem.artist
                };
                
                // Check if we have audio URL
                if (!playItem.audio_url && !playItem.preview_url) {
                    console.log('🎵 No audio URL available, using navigation fallback');
                    if (normalizedItem.id) {
                        window.location.href = `/player?id=${normalizedItem.id}&type=track`;
                    } else {
                        window.location.href = `/music`;
                    }
                    return;
                }
                
                console.log('🎵 Using window.mediaPlayer', playItem);
                window.mediaPlayer.play(playItem);
                
                // Update the index to show as playing
                // The index is already set above, but we ensure it stays in sync
                
                // Listen for track changes from media player
                if (window.mediaPlayer && window.mediaPlayer.on) {
                    const checkCurrentTrack = () => {
                        if (window.mediaPlayer.currentTrack) {
                            const displayedItems = this.feedItems.slice(0, 4);
                            const foundIndex = displayedItems.findIndex(i => {
                                const itemId = i.id || i.track_id || i.show_id;
                                const currentId = window.mediaPlayer.currentTrack.id || 
                                                window.mediaPlayer.currentTrack.track_id;
                                return itemId && currentId && itemId === currentId;
                            });
                            if (foundIndex !== -1) {
                                this.currentIndex = foundIndex;
                            }
                        }
                    };
                    window.mediaPlayer.on('play', checkCurrentTrack);
                    window.mediaPlayer.on('trackchange', checkCurrentTrack);
                }
                
                setTimeout(() => this.startHeroRotation(), 10000);
                return;
            }
            
            // Fallback: navigate to music page
            console.log('🎵 No player available, using navigation fallback');
            if (normalizedItem.id) {
                window.location.href = `/player?id=${normalizedItem.id}&type=track`;
            } else {
                window.location.href = `/music`;
            }
        },
        
        playShow(show, index = null) {
            if (index !== null) {
                this.currentShowIndex = index;
            }
            window.location.href = `/player?id=${show.id}&type=show`;
        },
        
        viewArtist(artist) {
            window.location.href = `/artists`;
        },

        // Playlist management
        async loadUserPlaylists() {
            try {
                const response = await fetch('/api/playlists');
                if (response.ok) {
                    const data = await response.json();
                    this.userPlaylists = data.playlists || [];
                }
            } catch (error) {
                console.error('Error loading user playlists:', error);
            }
        },

        createPlaylist() {
            if (!window.ahoyApp || !window.ahoyApp.isLoggedIn) {
                this.showCreateAccountModal = true;
                return;
            }
            
            // Redirect to my saves page to create playlist
            window.location.href = '/my-saves';
        },

        viewPlaylist(playlistId) {
            if (!window.ahoyApp || !window.ahoyApp.isLoggedIn) {
                this.showCreateAccountModal = true;
                return;
            }
            
            // Redirect to my saves page to view playlist
            window.location.href = '/my-saves';
        },

        showCreateAccountModal() {
            this.showCreateAccountModal = true;
        },

        closeCreateAccountModal() {
            this.showCreateAccountModal = false;
        },

        goToAuth() {
            window.location.href = '/auth';
        },

        // Save warning system
        setupSaveWarning() {
            // Track when user creates content
            this.trackUserActivity();
            
            // Warn before leaving page
            window.addEventListener('beforeunload', (e) => {
                if (this.hasUnsavedWork) {
                    e.preventDefault();
                    e.returnValue = 'You have unsaved work. Are you sure you want to leave?';
                    return e.returnValue;
                }
            });
        },

        trackUserActivity() {
            // Listen for save/unsave actions
            document.addEventListener('click', (e) => {
                if (e.target.closest('[data-bookmark]') || e.target.closest('[data-bookmark-action]')) {
                    this.hasUnsavedWork = true;
                }
            });

            // Listen for playlist creation
            document.addEventListener('click', (e) => {
                if (e.target.closest('[data-create-playlist]')) {
                    this.hasUnsavedWork = true;
                }
            });
        },

        // Check if user is logged in
        get isLoggedIn() {
            return window.ahoyApp && window.ahoyApp.isLoggedIn;
        },

        // New playlist creation
        async createNewPlaylist() {
            if (!this.newPlaylistName.trim()) {
                return;
            }

            if (!window.ahoyApp || !window.ahoyApp.isLoggedIn) {
                this.showCreateAccountModal = true;
                return;
            }

            try {
                const response = await fetch('/api/playlists', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        name: this.newPlaylistName.trim(),
                        description: this.newPlaylistDescription.trim(),
                        color: '#6366f1',
                        is_public: false
                    })
                });

                if (response.ok) {
                    const data = await response.json();
                    if (data.success) {
                        // Clear form and close
                        this.clearPlaylistForm();
                        // Reload playlists
                        await this.loadUserPlaylists();
                        // Show success message
                        if (window.ahoyApp && window.ahoyApp.showNotification) {
                            window.ahoyApp.showNotification('Playlist created successfully!', 'success');
                        }
                    }
                } else {
                    const error = await response.json();
                    if (window.ahoyApp && window.ahoyApp.showNotification) {
                        window.ahoyApp.showNotification('Failed to create playlist: ' + error.error, 'error');
                    }
                }
            } catch (error) {
                console.error('Error creating playlist:', error);
                if (window.ahoyApp && window.ahoyApp.showNotification) {
                    window.ahoyApp.showNotification('Failed to create playlist', 'error');
                }
            }
        },

        clearPlaylistForm() {
            this.newPlaylistName = '';
            this.newPlaylistDescription = '';
            this.showPlaylistForm = false;
        },

        togglePlaylistForm() {
            this.showPlaylistForm = !this.showPlaylistForm;
            if (!this.showPlaylistForm) {
                this.clearPlaylistForm();
            }
        },
        
        // Radio functions
        async loadRadioFeed() {
            try {
                const response = await fetch('/api/music');
                const data = await response.json();
                const tracks = (data.tracks || []).filter(t => t.audio_url || t.preview_url);
                // Deduplicate by id
                const seen = new Set();
                this.radioTracks = tracks.filter(t => {
                    if (seen.has(t.id)) return false;
                    seen.add(t.id);
                    return true;
                });
                this._buildRadioQueue();
            } catch (error) {
                console.error('Error loading radio feed:', error);
            }
        },
        
        _buildRadioQueue() {
            const list = [...this.radioTracks];
            if (this.radioShuffle) {
                list.sort(() => 0.5 - Math.random());
            }
            this.radioQueue = list.map(t => ({ ...t, type: 'track' }));
            this.radioUpNext = this.radioQueue.slice(0, 20);
        },
        
        setupRadioSync() {
            // Check if media player is already playing a track
            if (window.mediaPlayer && window.mediaPlayer.currentTrack) {
                const current = window.mediaPlayer.currentTrack;
                // Check if it's from our radio feed
                const isRadioTrack = this.radioTracks.some(t => 
                    (t.id && current.id && String(t.id) === String(current.id)) ||
                    (t.track_id && current.track_id && String(t.track_id) === String(current.track_id))
                );
                if (isRadioTrack) {
                    this.radioCurrent = current;
                    this.radioIsPlaying = window.mediaPlayer.isPlaying || false;
                }
            }
            
            // Listen for media player events
            if (window.mediaPlayer && window.mediaPlayer.on) {
                window.mediaPlayer.on('play', () => {
                    if (window.mediaPlayer.currentTrack) {
                        const current = window.mediaPlayer.currentTrack;
                        const isRadioTrack = this.radioTracks.some(t => 
                            (t.id && current.id && String(t.id) === String(current.id)) ||
                            (t.track_id && current.track_id && String(t.track_id) === String(current.track_id))
                        );
                        if (isRadioTrack) {
                            // Store previous track before updating
                            if (this.radioCurrent && (!this.radioPrevious || this.radioPrevious.id !== current.id)) {
                                this.radioPrevious = this.radioCurrent;
                            }
                            this.radioCurrent = current;
                            this.radioIsPlaying = true;
                            // Update queue if track was played
                            this._updateRadioQueueAfterPlay(current);
                        }
                    }
                });
                
                window.mediaPlayer.on('pause', () => {
                    this.radioIsPlaying = false;
                });
                
                window.mediaPlayer.on('trackchange', () => {
                    if (window.mediaPlayer.currentTrack) {
                        const current = window.mediaPlayer.currentTrack;
                        const isRadioTrack = this.radioTracks.some(t => 
                            (t.id && current.id && String(t.id) === String(current.id)) ||
                            (t.track_id && current.track_id && String(t.track_id) === String(current.track_id))
                        );
                        if (isRadioTrack) {
                            // Store previous track before updating
                            if (this.radioCurrent && (!this.radioPrevious || this.radioPrevious.id !== current.id)) {
                                this.radioPrevious = this.radioCurrent;
                            }
                            this.radioCurrent = current;
                            this._updateRadioQueueAfterPlay(current);
                        }
                    }
                });
                
                window.mediaPlayer.on('ended', () => {
                    // Auto-play next track when current ends
                    setTimeout(() => {
                        if (this.radioQueue.length === 0) {
                            this._buildRadioQueue();
                        }
                        this._playNextRadio();
                    }, 500);
                });
            }
        },
        
        _updateRadioQueueAfterPlay(track) {
            // Remove played track from queue if it exists
            const trackId = track.id || track.track_id;
            this.radioQueue = this.radioQueue.filter(t => {
                const tId = t.id || t.track_id;
                return tId && trackId && String(tId) !== String(trackId);
            });
            this.radioUpNext = this.radioQueue.slice(0, 20);
        },
        
        toggleRadio() {
            if (!window.mediaPlayer) {
                console.error('Media player not available');
                return;
            }
            
            if (this.radioIsPlaying) {
                window.mediaPlayer.pause();
                this.radioIsPlaying = false;
            } else {
                if (!this.radioCurrent) {
                    this._playNextRadio();
                } else {
                    window.mediaPlayer.resume();
                    this.radioIsPlaying = true;
                }
            }
        },
        
        skipRadio() {
            if (!window.mediaPlayer) {
                console.error('Media player not available');
                return;
            }
            this._playNextRadio();
        },
        
        playRadioTrack(track) {
            if (!window.mediaPlayer) {
                console.error('Media player not available');
                return;
            }
            
            const playItem = {
                ...track,
                type: 'track',
                audio_url: track.audio_url || track.preview_url || track.full_url
            };
            
            // Store current as previous before updating
            if (this.radioCurrent) {
                this.radioPrevious = this.radioCurrent;
            }
            
            this.radioCurrent = playItem;
            window.mediaPlayer.play(playItem);
            this.radioIsPlaying = true;
            this._updateRadioQueueAfterPlay(playItem);
        },
        
        _playNextRadio() {
            if (!window.mediaPlayer) {
                return;
            }
            
            if (this.radioQueue.length === 0) {
                this._buildRadioQueue();
            }
            
            const next = this.radioQueue.shift();
            if (next) {
                const playItem = {
                    ...next,
                    type: 'track',
                    audio_url: next.audio_url || next.preview_url || next.full_url
                };
                // Store current as previous before updating
                if (this.radioCurrent) {
                    this.radioPrevious = this.radioCurrent;
                }
                this.radioCurrent = playItem;
                window.mediaPlayer.play(playItem);
                this.radioIsPlaying = true;
                this.radioUpNext = this.radioQueue.slice(0, 20);
            }
        }
    }
}

// Home Bookmarks Widget
function homeBookmarksWidget() {
    return {
        bookmarks: {},
        
        loadBookmarks() {
            // Wait for bookmark system to be ready
            setTimeout(() => {
                this.refreshBookmarks();
            }, 500);
            
            // Listen for bookmark changes
            document.addEventListener('bookmarks:changed', () => {
                this.refreshBookmarks();
            });
        },
        
        refreshBookmarks() {
            this.bookmarks = {};
            if (window.AhoyBookmarks) {
                const items = window.AhoyBookmarks.all();
                items.forEach(item => {
                    this.bookmarks[item.key] = item;
                });
            } else {
                // Fallback to localStorage
                try {
                    const rawData = localStorage.getItem('ahoy.bookmarks.v1');
                    if (rawData) {
                        const data = JSON.parse(rawData);
                        if (data.items) {
                            Object.values(data.items).forEach(item => {
                                this.bookmarks[item.key] = item;
                            });
                        }
                    }
                } catch (e) {
                    console.error('Error reading bookmarks:', e);
                }
            }
        },
        
        bookmarksList() {
            return Object.values(this.bookmarks || {});
        },
        
        playBookmark(bookmark) {
            console.log('🎵 Playing bookmark:', bookmark);
            console.log('🎵 Available players:', {
                mediaPlayer: !!window.mediaPlayer,
                PlayerControls: !!window.PlayerControls,
                globalPlayer: !!window.globalPlayer
            });
            
            if (bookmark.type === 'track') {
                // Try to play directly with media player first
                if (window.mediaPlayer && typeof window.mediaPlayer.play === 'function') {
                    console.log('🎵 Using window.mediaPlayer for bookmark');
                    window.mediaPlayer.play(bookmark);
                    return;
                } else if (window.PlayerControls && typeof window.PlayerControls.play === 'function') {
                    console.log('🎵 Using window.PlayerControls for bookmark');
                    window.PlayerControls.play(bookmark);
                    return;
                } else if (window.globalPlayer && typeof window.globalPlayer.play === 'function') {
                    console.log('🎵 Using window.globalPlayer for bookmark');
                    window.globalPlayer.play(bookmark);
                    return;
                }
                console.log('🎵 No player available for bookmark, using custom event');
                // Fallback to custom event
                document.dispatchEvent(new CustomEvent('play-track', {
                    detail: { track: bookmark }
                }));
            } else if (bookmark.type === 'show') {
                console.log('🎵 Playing bookmark show, navigating to player');
                // Navigate to show player
                window.location.href = `/player?id=${bookmark.id}&type=show`;
            } else if (bookmark.type === 'artist') {
                console.log('🎵 Playing bookmark artist, navigating to artists page');
                // Navigate to artist page
                window.location.href = `/artists/${bookmark.id}`;
            }
        }
    };
}

// Recently Added widget logic
function recentlyAdded() {
    return {
        isLoading: true,
        latestItems: [],
        latestDateText: '',
        async init() {
            try {
                // Use shared data store to prevent duplicate calls
                const [musicData, showsData] = await Promise.all([
                    window.__ahoyDataStore ? window.__ahoyDataStore.getMusic() : (await fetch('/api/music')).json(),
                    window.__ahoyDataStore ? window.__ahoyDataStore.getShows() : (await fetch('/api/shows')).json()
                ]);

                const tracks = (musicData.tracks || []).map(t => ({
                    ...t,
                    type: t.type || 'track',
                    dateComparable: this.parseAnyDate(t.added_date || t.date_added)
                }));
                const shows = (showsData.shows || []).map(s => ({
                    ...s,
                    type: 'show',
                    title: s.title,
                    artist: s.host,
                    cover_art: s.thumbnail,
                    dateComparable: this.parseAnyDate(s.published_date || s.added_date)
                }));

                // Combine and find latest date
                const combined = [...tracks, ...shows].filter(i => i.dateComparable);
                combined.sort((a, b) => b.dateComparable - a.dateComparable);

                const latestDate = combined.length ? combined[0].dateComparable : null;
                if (latestDate) {
                    // Show up to 6 items with that same latest date
                    const sameDay = combined.filter(i => this.isSameDay(i.dateComparable, latestDate)).slice(0, 6);
                    this.latestItems = sameDay;
                    this.latestDateText = `Updated ${this.humanDate(latestDate)}`;
                } else {
                    this.latestItems = combined.slice(0, 6);
                }
            } catch (e) {
                console.error('Error loading Recently Added:', e);
            } finally {
                this.isLoading = false;
            }
        },
        play(item) {
            if (item.type === 'show') {
                window.location.href = `/player?id=${item.id}&type=show`;
                return;
            }
            if (window.mediaPlayer && typeof window.mediaPlayer.play === 'function') {
                window.mediaPlayer.play(item);
                return;
            }
            if (window.globalPlayer && typeof window.globalPlayer.play === 'function') {
                window.globalPlayer.play(item);
                return;
            }
            window.location.href = `/music?highlight=${item.id}`;
        },
        parseAnyDate(d) {
            if (!d) return null;
            // Try ISO (YYYY-MM-DD)
            const iso = Date.parse(d);
            if (!isNaN(iso)) return new Date(iso);
            // Try MM-DD-YY or MM-DD-YYYY
            const parts = String(d).replace(/\//g, '-').split('-').map(x => x.trim());
            if (parts.length >= 2) {
                let [mm, dd, yy] = parts;
                mm = parseInt(mm, 10); dd = parseInt(dd, 10);
                if (!isNaN(mm) && !isNaN(dd)) {
                    let yyyy = parseInt(yy, 10);
                    if (!isNaN(yyyy)) {
                        if (yyyy < 100) yyyy = 2000 + yyyy; // assume 20xx
                        return new Date(yyyy, mm - 1, dd);
                    }
                }
            }
            return null;
        },
        isSameDay(a, b) {
            return a.getFullYear() === b.getFullYear() && a.getMonth() === b.getMonth() && a.getDate() === b.getDate();
        },
        humanDate(d) {
            try {
                return d.toLocaleDateString(undefined, { year: 'numeric', month: 'short', day: 'numeric' });
            } catch (_) { return ''; }
        }
    };
}

// What's New at Ahoy widget
function whatsNew() {
    return {
        updates: [],
        isLoading: true,
        
        async loadUpdates() {
            try {
                const response = await fetch('/api/whats-new');
                const data = await response.json();
                this.updates = (data.updates || []).slice(0, 4); // Show up to 4 updates
            } catch (error) {
                console.error('Error loading what\'s new updates:', error);
                this.updates = [];
            } finally {
                this.isLoading = false;
            }
        },
        
        formatDate(dateString) {
            if (!dateString) return '';
            try {
                const date = new Date(dateString);
                return date.toLocaleDateString(undefined, { 
                    year: 'numeric', 
                    month: 'short', 
                    day: 'numeric' 
                });
            } catch (e) {
                return dateString;
            }
        }
    };
}
</script>
{% endblock %}