{% extends "base.html" %}

{% block title %}Ahoy Indie Media - Music Hub{% endblock %}

{% block content %}
<div class="home-page" x-data="homePage()" x-init="init()">
    <!-- TV-Style Hero Feed -->
    <section class="tv-hero">
        <div class="hero-feed"
            :style="`transform: translateX(${heroOffset}px)`"
            @touchstart="handleTouchStart"
            @touchmove="handleTouchMove"
            @touchend="handleTouchEnd">
            <template x-for="(item, index) in heroItems" :key="item.id">
                <div class="hero-item" x-show="item.cover_art || item.thumbnail"
                    :class="{'active': currentHeroIndex === index}"
                    :style="`background-image: url(${item.cover_art || item.thumbnail})`"
                    @click="playItem(item, index)">
                    <div class="hero-overlay">
                        <div class="hero-content">
                            <div class="hero-badge"
                                x-text="item.type?.toUpperCase()"></div>
                            <h1 x-text="item.title"></h1>
                            <p x-text="item.artist"></p>
                            <button @click.stop="playItem(item, index)"
                                class="hero-play-btn">
                                <i class="fas fa-play"></i>
                            </button>
                        </div>
                    </div>
                </div>
            </template>
        </div>
        <div class="hero-controls">
            <button @click="prevHero()" class="hero-nav">
                <i class="fas fa-chevron-left"></i>
            </button>
            <button @click="nextHero()" class="hero-nav">
                <i class="fas fa-chevron-right"></i>
            </button>
        </div>
        <div class="hero-indicators">
            <template x-for="(item, index) in heroItems" :key="item.id">
                <button @click="setHeroIndex(index)"
                    :class="{'active': currentHeroIndex === index}"
                    class="hero-dot"></button>
            </template>
        </div>
    </section>

    <!-- Compact Discovery Grid -->
    <section class="discovery-grid">
        <div class="grid-container">

            <!-- Now Playing Compact -->
            <div class="grid-item now-playing-compact">
                <div class="item-header">
                    <h3><i class="fas fa-music"></i> Now Playing</h3>
                    <button @click="playRandom()" class="shuffle-btn">
                        <i class="fas fa-random"></i>
                    </button>
                </div>
                <div class="playing-list">
                    <template x-for="(item, index) in feedItems.slice(0, 4)"
                        :key="item.id">
                        <div class="playing-item"
                            x-show="item.cover_art || item.thumbnail"
                            :class="{'playing': currentIndex === index}"
                            :style="`background-image: linear-gradient(rgba(0,0,0,0.6), rgba(0,0,0,0.8)), url(${item.cover_art || item.thumbnail}); background-size: cover; background-position: center;`"
                            @click="playItem(item, index)">
                            <div class="item-details">
                                <h4 x-text="item.title"></h4>
                                <p x-text="item.artist"></p>
                            </div>
                            <div class="play-indicator"
                                x-show="currentIndex === index">
                                <i class="fas fa-play"></i>
                            </div>
                        </div>
                    </template>
                </div>
            </div>

            <!-- Live Shows Compact -->
            <div class="grid-item shows-compact">
                <div class="item-header">
                    <h3><i class="fas fa-play-circle"></i> Live Now</h3>
                    <a href="/shows" class="view-all-btn">All</a>
                </div>
                <div class="playing-list">
                    <template x-for="(show, index) in featuredShows.slice(0, 4)"
                        :key="show.id">
                        <div class="playing-item"
                            x-show="show.thumbnail"
                            :class="{'playing': currentShowIndex === index}"
                            :style="`background-image: linear-gradient(rgba(0,0,0,0.6), rgba(0,0,0,0.8)), url(${show.thumbnail}); background-size: cover; background-position: center;`"
                            @click="playShow(show, index)">
                            <div class="item-details">
                                <h4 x-text="show.title"></h4>
                                <p x-text="show.host"></p>
                            </div>
                            <div class="play-indicator"
                                x-show="currentShowIndex === index">
                                <i class="fas fa-play"></i>
                            </div>
                        </div>
                    </template>
                </div>
            </div>

            <!-- Quick Actions Compact -->
            <div class="grid-item quick-actions">
                <div class="item-header">
                    <h3><i class="fas fa-th-large"></i> Explore</h3>
                </div>
                <div class="action-grid">
                    <a href="/music" class="action-card">
                        <i class="fas fa-music"></i>
                        <span>Music</span>
                    </a>
                    <a href="/shows" class="action-card">
                        <i class="fas fa-play-circle"></i>
                        <span>Shows</span>
                    </a>
                    <a href="/artists" class="action-card">
                        <i class="fas fa-users"></i>
                        <span>Artists</span>
                    </a>
                    <a href="/bookmarks" class="action-card">
                        <i class="fas fa-bookmark"></i>
                        <span>Bookmarks</span>
                    </a>
                </div>
            </div>

            <!-- My Bookmarks Widget -->
            <div class="grid-item bookmarks-widget"
                x-data="homeBookmarksWidget()" x-init="loadBookmarks()">
                <div class="item-header">
                    <h3><i class="fas fa-bookmark"></i> My Bookmarks</h3>
                    <a href="/bookmarks" class="view-all-btn"
                        x-show="bookmarksList().length > 0">
                        <span x-text="bookmarksList().length"></span>
                    </a>
                </div>
                <div class="bookmarks-content">
                    <!-- Empty State -->
                    <div class="bookmarks-empty"
                        x-show="bookmarksList().length === 0">
                        <div class="empty-state">
                            <i class="fas fa-bookmark"></i>
                            <h4>No Bookmarks Yet</h4>
                            <p>Start bookmarking your favorite tracks, shows,
                                and artists!</p>
                            <div class="bookmark-tips">
                                <a href="/music" class="tip-link">
                                    <i class="fas fa-music"></i> Browse Music
                                </a>
                                <a href="/shows" class="tip-link">
                                    <i class="fas fa-tv"></i> Watch Shows
                                </a>
                            </div>
                        </div>
                    </div>

                    <!-- Bookmarks Preview -->
                    <div class="bookmarks-preview playing-list"
                        x-show="bookmarksList().length > 0">
                        <template
                            x-for="bookmark in bookmarksList().slice(0, 4)"
                            :key="bookmark.key">
                            <div class="playing-item"
                                :style="`background-image: linear-gradient(rgba(0,0,0,0.4), rgba(0,0,0,0.7)), url(${bookmark.artwork || '/static/img/default-cover.jpg'}); background-size: cover; background-position: center;`"
                                @click="playBookmark(bookmark)">
                                <div class="item-details">
                                    <h4 x-text="bookmark.title"></h4>
                                    <p x-text="bookmark.type"></p>
                                </div>
                                <div class="play-indicator">
                                    <i class="fas fa-play"></i>
                                </div>
                            </div>
                        </template>
                    </div>

                    <!-- View All Link -->
                    <a href="/bookmarks" class="view-all-btn bookmark-view-all"
                        x-show="bookmarksList().length > 4">
                        <i class="fas fa-arrow-right"></i> View All Bookmarks
                    </a>
                </div>
            </div>
            <!-- Recently Added (Latest Updates) -->
            <div class="grid-item recently-added" x-data="recentlyAdded()"
                x-init="init()">
                <div class="item-header">
                    <h3><i class="fas fa-bolt"></i> Recently Added</h3>
                    <span class="view-all-btn" x-show="latestDateText"
                        x-text="latestDateText"></span>
                </div>
                <div x-show="isLoading" class="playing-list">
                    <div class="playing-item"
                        style="opacity:.6;display:flex;align-items:center;justify-content:center;">
                        <span>Loading latestâ€¦</span>
                    </div>
                </div>
                <div class="playing-list">
                    <template x-for="item in latestItems" :key="item.id">
                        <div class="playing-item"
                            x-show="item.cover_art || item.thumbnail"
                            :style="`background-image: linear-gradient(rgba(0,0,0,0.6), rgba(0,0,0,0.8)), url(${item.cover_art || item.thumbnail}); background-size: cover; background-position: center;`"
                            @click="play(item)">
                            <div class="item-details">
                                <h4 x-text="item.title"></h4>
                                <p
                                    x-text="item.artist || (item.host || '')"></p>
                            </div>
                            <div class="play-indicator">
                                <i class="fas fa-play"></i>
                            </div>
                        </div>
                    </template>
                </div>
            </div>
        </div>
    </section>

    <!-- New Haven Events Promotional Banner -->
    <section class="newhaven-promo-section">
        <div class="promo-container">
            <div class="promo-content">
                <div class="promo-header">

                    <div class="promo-title">
                        <h2>Ahoy New Haven</h2>
                        <p>Discover live shows, poetry readings, and indie
                            performances in New Haven</p>
                        <p class="beta-notice">Custom built web app beta - help
                            us improve!</p>
                    </div>
                </div>

                <div class="promo-events">
                    <div class="event-card featured">
                        <div class="event-date-badge">
                            <span class="event-day">26</span>
                            <span class="event-month">Sep</span>
                        </div>
                        <div class="event-info">
                            <h3>Poets and Friends #3</h3>
                            <p class="event-venue">Koffee? â€¢ 104 Audubon
                                Street</p>
                            <p class="event-time">6:30 PM â€¢ Doors open at 6pm,
                                showtime 6:30pm SHARP</p>
                            <p class="event-description">Live poetry +
                                performance featuring local poets, hosted by
                                Mickey Vampiro, with merch available and show
                                running 60-90 minutes.</p>
                        </div>
                    </div>

                    <div class="event-card">
                        <div class="event-date-badge">
                            <span class="event-day">17</span>
                            <span class="event-month">Oct</span>
                        </div>
                        <div class="event-info">
                            <h3>Ahoy Show Jams</h3>
                            <p class="event-venue">Most Likely Koffee? â€¢ 104
                                Audubon Street</p>
                            <p class="event-time">TBD â€¢ Live music showcase</p>
                            <p class="event-description">Live music showcase
                                featuring Jake Custer and indie artists from New
                                Haven in an intimate venue setting.</p>
                        </div>
                    </div>
                </div>

                <div class="promo-actions">
                    <a href="https://newhaven.ahoy.ooo" target="_blank"
                        class="promo-btn primary">
                        Visit New Haven Events
                    </a>
                    <a href="https://newhaven.ahoy.ooo" target="_blank"
                        class="promo-btn secondary">
                        View All Events
                    </a>
                    <a href="/feedback" class="promo-btn secondary">
                        Give Feedback
                    </a>
                </div>
            </div>
        </div>
    </section>

    <!-- Loading State -->
    <section x-show="isLoading" class="loading-section">
        <div class="spinner"></div>
        <p>Loading awesome content...</p>
    </section>

    <!-- Create Account Modal -->
    <div x-show="showCreateAccountModal" class="modal-overlay"
        @click="closeCreateAccountModal()">
        <div class="modal-content create-account-modal" @click.stop>
            <div class="modal-header">
                <h3>Save Your Work</h3>
                <button @click="closeCreateAccountModal()"
                    class="close-btn">&times;</button>
            </div>
            <div class="modal-body">
                <div class="save-warning-icon">
                    <i class="fas fa-exclamation-triangle"></i>
                </div>
                <h4>Don't Lose Your Work!</h4>
                <p>You're creating playlists and saving content, but without an
                    account, your work will be lost when you leave this
                    page.</p>
                <div class="benefits-list">
                    <div class="benefit-item">
                        <i class="fas fa-check"></i>
                        <span>Save playlists permanently</span>
                    </div>
                    <div class="benefit-item">
                        <i class="fas fa-check"></i>
                        <span>Access your content anywhere</span>
                    </div>
                    <div class="benefit-item">
                        <i class="fas fa-check"></i>
                        <span>Sync across devices</span>
                    </div>
                    <div class="benefit-item">
                        <i class="fas fa-check"></i>
                        <span>Get personalized recommendations</span>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button @click="closeCreateAccountModal()"
                    class="btn btn-secondary">Continue as Guest</button>
                <button @click="goToAuth()" class="btn btn-primary">
                    <i class="fas fa-user-plus"></i> Create Free Account
                </button>
            </div>
        </div>
    </div>
</div>

<script>
function homePage() {
    return {
        // State
        isLoading: true,
        feedItems: [],
        featuredArtist: null,
        featuredShows: [],
        heroItems: [],
        currentIndex: 0,
        currentShowIndex: 0,
        currentHeroIndex: 0,
        heroOffset: 0,
        heroInterval: null,
        touchStartX: 0,
        touchStartY: 0,
        isDragging: false,
        userPlaylists: [],
        hasUnsavedWork: false,
        showCreateAccountModal: false,
        newPlaylistName: '',
        newPlaylistDescription: '',
        showPlaylistForm: false,
        
        // Initialize
        async init() {
            await this.loadAllData();
            this.isLoading = false;
            this.startHeroRotation();
            
            // Load user playlists if logged in
            if (window.ahoyApp && window.ahoyApp.isLoggedIn) {
                await this.loadUserPlaylists();
            }
            
            // Set up save warning system
            this.setupSaveWarning();
            
            // Add resize listener to recalculate hero offset
            window.addEventListener('resize', () => {
                this.updateHeroOffset();
            });
            
            // Expose functions globally for keyplaylist navigation
            window.homePage = this;
        },
        
        // Data loading
        async loadAllData() {
            try {
                await Promise.all([
                    this.loadNowPlaying(),
                    this.loadFeaturedArtist(),
                    this.loadFeaturedShows()
                ]);
                this.prepareHeroItems();
            } catch (error) {
                console.error('Error loading data:', error);
            }
        },
        
        async loadNowPlaying() {
            try {
                const response = await fetch('/api/now-playing');
                const data = await response.json();
                this.feedItems = data.feed || [];
            } catch (error) {
                console.error('Error loading now playing:', error);
            }
        },
        
        async loadFeaturedArtist() {
            try {
                const response = await fetch('/api/artists');
                const data = await response.json();
                const artists = data.artists || [];
                this.featuredArtist = artists[Math.floor(Math.random() * artists.length)];
            } catch (error) {
                console.error('Error loading featured artist:', error);
            }
        },
        
        async loadFeaturedShows() {
            try {
                const response = await fetch('/api/shows');
                const data = await response.json();
                const shows = data.shows || [];
                this.featuredShows = shows.sort(() => 0.5 - Math.random()).slice(0, 3);
            } catch (error) {
                console.error('Error loading featured shows:', error);
            }
        },
        
        prepareHeroItems() {
            // Mix music and shows for hero feed
            const musicItems = this.feedItems.slice(0, 4);
            const showItems = this.featuredShows.slice(0, 2);
            this.heroItems = [...musicItems, ...showItems].sort(() => 0.5 - Math.random());
            
            // Calculate initial hero offset after items are set
            setTimeout(() => {
                this.updateHeroOffset();
            }, 100);
        },
        
        startHeroRotation() {
            this.heroInterval = setInterval(() => {
                this.nextHero();
            }, 5000); // Change every 5 seconds
        },
        
        stopHeroRotation() {
            if (this.heroInterval) {
                clearInterval(this.heroInterval);
                this.heroInterval = null;
            }
        },
        
        // Hero navigation
        nextHero() {
            if (this.currentHeroIndex < this.heroItems.length - 1) {
                this.currentHeroIndex++;
            } else {
                this.currentHeroIndex = 0;
            }
            this.updateHeroOffset();
        },
        
        prevHero() {
            if (this.currentHeroIndex > 0) {
                this.currentHeroIndex--;
            } else {
                this.currentHeroIndex = this.heroItems.length - 1;
            }
            this.updateHeroOffset();
        },
        
        setHeroIndex(index) {
            this.currentHeroIndex = index;
            this.updateHeroOffset();
        },
        
        updateHeroOffset() {
            // Get the width of the hero container to calculate proper offset
            const heroContainer = document.querySelector('.tv-hero');
            if (heroContainer) {
                const containerWidth = heroContainer.offsetWidth;
                this.heroOffset = -this.currentHeroIndex * containerWidth;
            } else {
                // Fallback to 100% if container not found
                this.heroOffset = -this.currentHeroIndex * 100;
            }
        },
        
        // Touch handling for mobile swipe
        handleTouchStart(event) {
            this.touchStartX = event.touches[0].clientX;
            this.touchStartY = event.touches[0].clientY;
            this.isDragging = false;
            this.stopHeroRotation();
        },
        
        handleTouchMove(event) {
            if (!this.touchStartX) return;
            
            const touchX = event.touches[0].clientX;
            const touchY = event.touches[0].clientY;
            const diffX = this.touchStartX - touchX;
            const diffY = this.touchStartY - touchY;
            
            // Only consider it a drag if horizontal movement is greater than vertical
            if (Math.abs(diffX) > Math.abs(diffY)) {
                this.isDragging = true;
                event.preventDefault();
            }
        },
        
        handleTouchEnd(event) {
            if (!this.isDragging || !this.touchStartX) {
                this.startHeroRotation();
                return;
            }
            
            const touchX = event.changedTouches[0].clientX;
            const diffX = this.touchStartX - touchX;
            const threshold = 50; // Minimum swipe distance
            
            if (Math.abs(diffX) > threshold) {
                if (diffX > 0) {
                    // Swiped left - go to next
                    this.nextHero();
                } else {
                    // Swiped right - go to previous
                    this.prevHero();
                }
            }
            
            this.touchStartX = 0;
            this.touchStartY = 0;
            this.isDragging = false;
            this.startHeroRotation();
        },
        
        // Actions
        playRandom() {
            if (this.feedItems.length > 0) {
                const randomIndex = Math.floor(Math.random() * this.feedItems.length);
                this.playItem(this.feedItems[randomIndex], randomIndex);
            }
        },
        
        playItem(item, index) {
            this.currentIndex = index;
            this.stopHeroRotation();
            
            console.log('ðŸŽµ Playing item:', item);
            console.log('ðŸŽµ Available players:', {
                mediaPlayer: !!window.mediaPlayer,
                PlayerControls: !!window.PlayerControls,
                globalPlayer: !!window.globalPlayer
            });
            
            // Try to play directly if it's music and media player is available
            if (item.type === 'track' || item.type === 'music' || item.artist) {
                if (window.mediaPlayer && typeof window.mediaPlayer.play === 'function') {
                    console.log('ðŸŽµ Using window.mediaPlayer');
                    window.mediaPlayer.play(item);
                    setTimeout(() => this.startHeroRotation(), 10000);
                    return;
                } else if (window.PlayerControls && typeof window.PlayerControls.play === 'function') {
                    console.log('ðŸŽµ Using window.PlayerControls');
                    window.PlayerControls.play(item);
                    setTimeout(() => this.startHeroRotation(), 10000);
                    return;
                } else if (window.globalPlayer && typeof window.globalPlayer.play === 'function') {
                    console.log('ðŸŽµ Using window.globalPlayer');
                    window.globalPlayer.play(item);
                    setTimeout(() => this.startHeroRotation(), 10000);
                    return;
                }
                console.log('ðŸŽµ No player available, using navigation fallback');
                // Fallback to navigation
                window.location.href = `/music?highlight=${item.id}`;
            } else if (item.type === 'show') {
                console.log('ðŸŽµ Playing show, navigating to player');
                // For shows, navigate to player
                window.location.href = `/player?id=${item.id}&type=show`;
            } else {
                console.log('ðŸŽµ Unknown type, defaulting to shows');
                // Default to shows if no type specified
                window.location.href = `/shows?highlight=${item.id}`;
            }
            // Restart rotation after a delay
            setTimeout(() => this.startHeroRotation(), 10000);
        },
        
        playShow(show, index = null) {
            if (index !== null) {
                this.currentShowIndex = index;
            }
            window.location.href = `/player?id=${show.id}&type=show`;
        },
        
        viewArtist(artist) {
            window.location.href = `/artists`;
        },

        // Playlist management
        async loadUserPlaylists() {
            try {
                const response = await fetch('/api/playlists');
                if (response.ok) {
                    const data = await response.json();
                    this.userPlaylists = data.playlists || [];
                }
            } catch (error) {
                console.error('Error loading user playlists:', error);
            }
        },

        createPlaylist() {
            if (!window.ahoyApp || !window.ahoyApp.isLoggedIn) {
                this.showCreateAccountModal = true;
                return;
            }
            
            // Redirect to my saves page to create playlist
            window.location.href = '/my-saves';
        },

        viewPlaylist(playlistId) {
            if (!window.ahoyApp || !window.ahoyApp.isLoggedIn) {
                this.showCreateAccountModal = true;
                return;
            }
            
            // Redirect to my saves page to view playlist
            window.location.href = '/my-saves';
        },

        showCreateAccountModal() {
            this.showCreateAccountModal = true;
        },

        closeCreateAccountModal() {
            this.showCreateAccountModal = false;
        },

        goToAuth() {
            window.location.href = '/auth';
        },

        // Save warning system
        setupSaveWarning() {
            // Track when user creates content
            this.trackUserActivity();
            
            // Warn before leaving page
            window.addEventListener('beforeunload', (e) => {
                if (this.hasUnsavedWork) {
                    e.preventDefault();
                    e.returnValue = 'You have unsaved work. Are you sure you want to leave?';
                    return e.returnValue;
                }
            });
        },

        trackUserActivity() {
            // Listen for save/unsave actions
            document.addEventListener('click', (e) => {
                if (e.target.closest('[data-bookmark]') || e.target.closest('[data-bookmark-action]')) {
                    this.hasUnsavedWork = true;
                }
            });

            // Listen for playlist creation
            document.addEventListener('click', (e) => {
                if (e.target.closest('[data-create-playlist]')) {
                    this.hasUnsavedWork = true;
                }
            });
        },

        // Check if user is logged in
        get isLoggedIn() {
            return window.ahoyApp && window.ahoyApp.isLoggedIn;
        },

        // New playlist creation
        async createNewPlaylist() {
            if (!this.newPlaylistName.trim()) {
                return;
            }

            if (!window.ahoyApp || !window.ahoyApp.isLoggedIn) {
                this.showCreateAccountModal = true;
                return;
            }

            try {
                const response = await fetch('/api/playlists', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        name: this.newPlaylistName.trim(),
                        description: this.newPlaylistDescription.trim(),
                        color: '#6366f1',
                        is_public: false
                    })
                });

                if (response.ok) {
                    const data = await response.json();
                    if (data.success) {
                        // Clear form and close
                        this.clearPlaylistForm();
                        // Reload playlists
                        await this.loadUserPlaylists();
                        // Show success message
                        if (window.ahoyApp && window.ahoyApp.showNotification) {
                            window.ahoyApp.showNotification('Playlist created successfully!', 'success');
                        }
                    }
                } else {
                    const error = await response.json();
                    if (window.ahoyApp && window.ahoyApp.showNotification) {
                        window.ahoyApp.showNotification('Failed to create playlist: ' + error.error, 'error');
                    }
                }
            } catch (error) {
                console.error('Error creating playlist:', error);
                if (window.ahoyApp && window.ahoyApp.showNotification) {
                    window.ahoyApp.showNotification('Failed to create playlist', 'error');
                }
            }
        },

        clearPlaylistForm() {
            this.newPlaylistName = '';
            this.newPlaylistDescription = '';
            this.showPlaylistForm = false;
        },

        togglePlaylistForm() {
            this.showPlaylistForm = !this.showPlaylistForm;
            if (!this.showPlaylistForm) {
                this.clearPlaylistForm();
            }
        }
    }
}

// Home Bookmarks Widget
function homeBookmarksWidget() {
    return {
        bookmarks: {},
        
        loadBookmarks() {
            // Wait for bookmark system to be ready
            setTimeout(() => {
                this.refreshBookmarks();
            }, 500);
            
            // Listen for bookmark changes
            document.addEventListener('bookmarks:changed', () => {
                this.refreshBookmarks();
            });
        },
        
        refreshBookmarks() {
            this.bookmarks = {};
            if (window.AhoyBookmarks) {
                const items = window.AhoyBookmarks.all();
                items.forEach(item => {
                    this.bookmarks[item.key] = item;
                });
            } else {
                // Fallback to localStorage
                try {
                    const rawData = localStorage.getItem('ahoy.bookmarks.v1');
                    if (rawData) {
                        const data = JSON.parse(rawData);
                        if (data.items) {
                            Object.values(data.items).forEach(item => {
                                this.bookmarks[item.key] = item;
                            });
                        }
                    }
                } catch (e) {
                    console.error('Error reading bookmarks:', e);
                }
            }
        },
        
        bookmarksList() {
            return Object.values(this.bookmarks || {});
        },
        
        playBookmark(bookmark) {
            console.log('ðŸŽµ Playing bookmark:', bookmark);
            console.log('ðŸŽµ Available players:', {
                mediaPlayer: !!window.mediaPlayer,
                PlayerControls: !!window.PlayerControls,
                globalPlayer: !!window.globalPlayer
            });
            
            if (bookmark.type === 'track') {
                // Try to play directly with media player first
                if (window.mediaPlayer && typeof window.mediaPlayer.play === 'function') {
                    console.log('ðŸŽµ Using window.mediaPlayer for bookmark');
                    window.mediaPlayer.play(bookmark);
                    return;
                } else if (window.PlayerControls && typeof window.PlayerControls.play === 'function') {
                    console.log('ðŸŽµ Using window.PlayerControls for bookmark');
                    window.PlayerControls.play(bookmark);
                    return;
                } else if (window.globalPlayer && typeof window.globalPlayer.play === 'function') {
                    console.log('ðŸŽµ Using window.globalPlayer for bookmark');
                    window.globalPlayer.play(bookmark);
                    return;
                }
                console.log('ðŸŽµ No player available for bookmark, using custom event');
                // Fallback to custom event
                document.dispatchEvent(new CustomEvent('play-track', {
                    detail: { track: bookmark }
                }));
            } else if (bookmark.type === 'show') {
                console.log('ðŸŽµ Playing bookmark show, navigating to player');
                // Navigate to show player
                window.location.href = `/player?id=${bookmark.id}&type=show`;
            } else if (bookmark.type === 'artist') {
                console.log('ðŸŽµ Playing bookmark artist, navigating to artists page');
                // Navigate to artist page
                window.location.href = `/artists/${bookmark.id}`;
            }
        }
    };
}

// Recently Added widget logic
function recentlyAdded() {
    return {
        isLoading: true,
        latestItems: [],
        latestDateText: '',
        async init() {
            try {
                const [musicRes, showsRes] = await Promise.all([
                    fetch('/api/music'),
                    fetch('/api/shows')
                ]);
                const musicData = await musicRes.json();
                const showsData = await showsRes.json();

                const tracks = (musicData.tracks || []).map(t => ({
                    ...t,
                    type: t.type || 'track',
                    dateComparable: this.parseAnyDate(t.added_date || t.date_added)
                }));
                const shows = (showsData.shows || []).map(s => ({
                    ...s,
                    type: 'show',
                    title: s.title,
                    artist: s.host,
                    cover_art: s.thumbnail,
                    dateComparable: this.parseAnyDate(s.published_date || s.added_date)
                }));

                // Combine and find latest date
                const combined = [...tracks, ...shows].filter(i => i.dateComparable);
                combined.sort((a, b) => b.dateComparable - a.dateComparable);

                const latestDate = combined.length ? combined[0].dateComparable : null;
                if (latestDate) {
                    // Show up to 6 items with that same latest date
                    const sameDay = combined.filter(i => this.isSameDay(i.dateComparable, latestDate)).slice(0, 6);
                    this.latestItems = sameDay;
                    this.latestDateText = `Updated ${this.humanDate(latestDate)}`;
                } else {
                    this.latestItems = combined.slice(0, 6);
                }
            } catch (e) {
                console.error('Error loading Recently Added:', e);
            } finally {
                this.isLoading = false;
            }
        },
        play(item) {
            if (item.type === 'show') {
                window.location.href = `/player?id=${item.id}&type=show`;
                return;
            }
            if (window.mediaPlayer && typeof window.mediaPlayer.play === 'function') {
                window.mediaPlayer.play(item);
                return;
            }
            if (window.globalPlayer && typeof window.globalPlayer.play === 'function') {
                window.globalPlayer.play(item);
                return;
            }
            window.location.href = `/music?highlight=${item.id}`;
        },
        parseAnyDate(d) {
            if (!d) return null;
            // Try ISO (YYYY-MM-DD)
            const iso = Date.parse(d);
            if (!isNaN(iso)) return new Date(iso);
            // Try MM-DD-YY or MM-DD-YYYY
            const parts = String(d).replace(/\//g, '-').split('-').map(x => x.trim());
            if (parts.length >= 2) {
                let [mm, dd, yy] = parts;
                mm = parseInt(mm, 10); dd = parseInt(dd, 10);
                if (!isNaN(mm) && !isNaN(dd)) {
                    let yyyy = parseInt(yy, 10);
                    if (!isNaN(yyyy)) {
                        if (yyyy < 100) yyyy = 2000 + yyyy; // assume 20xx
                        return new Date(yyyy, mm - 1, dd);
                    }
                }
            }
            return null;
        },
        isSameDay(a, b) {
            return a.getFullYear() === b.getFullYear() && a.getMonth() === b.getMonth() && a.getDate() === b.getDate();
        },
        humanDate(d) {
            try {
                return d.toLocaleDateString(undefined, { year: 'numeric', month: 'short', day: 'numeric' });
            } catch (_) { return ''; }
        }
    };
}
</script>
{% endblock %}