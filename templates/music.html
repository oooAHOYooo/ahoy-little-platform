{% extends "base.html" %}

{% block title %}Music Library - Ahoy Indie Media{% endblock %}

{% block content %}
<div class="music-container" x-data="musicLibrary()" x-init="loadMusic()">
    {% from "macros/subpage_header.html" import subpage_hero, subpage_section_header %}
    {{ subpage_hero(title="Music Library", subtitle="Explore", icon_class="fas fa-music") }}

    <!-- Mobile: match Podcasts header + compact controls before the list -->
    <section class="podcasts-section mobile-only">
        {% call subpage_section_header("Browse") %}
        <button type="button" class="episode-btn"
            @click="playRandomTrack()" title="Play Random">
            <i class="fas fa-random" aria-hidden="true"></i>
            <span class="sr-only">Play Random</span>
        </button>
        {% endcall %}

        <div class="music-mobile-controls">
            <div class="search-bar">
                <i class="fas fa-search" aria-hidden="true"></i>
                <input type="text"
                    x-model="searchQuery"
                    @input="filterMusic()"
                    placeholder="Search music..."
                    class="search-input"
                    aria-label="Search music">
                <button @click="clearSearch()" class="search-clear"
                    x-show="searchQuery" aria-label="Clear search">
                    <i class="fas fa-times" aria-hidden="true"></i>
                </button>
            </div>

            <div class="music-mobile-row">
                <select x-model="selectedArtist" @change="filterMusic()"
                    aria-label="Filter by artist">
                    <option value>All Artists</option>
                    <template x-for="artist in artists" :key="artist">
                        <option :value="artist" x-text="artist"></option>
                    </template>
                </select>

                <select x-model="sortBy" @change="sortMusic()"
                    aria-label="Sort music">
                    <option value="title">Sort: Title</option>
                    <option value="artist">Sort: Artist</option>
                    <option value="plays">Sort: Plays</option>
                    <option value="added_date">Sort: Date Added</option>
                </select>
            </div>

            <div class="music-mobile-row">
                <div class="view-options" aria-label="View options">
                    <button @click="viewMode = 'grid'"
                        :class="{'active': viewMode === 'grid'}"
                        class="view-btn" type="button" aria-label="Grid view">
                        <i class="fas fa-th" aria-hidden="true"></i>
                    </button>
                    <button @click="viewMode = 'list'"
                        :class="{'active': viewMode === 'list'}"
                        class="view-btn" type="button" aria-label="List view">
                        <i class="fas fa-list" aria-hidden="true"></i>
                    </button>
                </div>
            </div>
        </div>
    </section>

    <!-- Unified Rotating Hero -->
    <section class="unified-hero tv-hero" x-data="createUnifiedHero({ pageType: 'music', rotationSpeed: 14000 })" x-init="init()"
        @touchstart="handleTouchStart" @touchmove="handleTouchMove" @touchend="handleTouchEnd">
        <div class="unified-hero-feed hero-feed" :style="`transform: translateX(${heroOffset}px)`">
            <template x-for="(item, index) in heroItems" :key="item.id">
                <div class="hero-item" x-show="getItemImage(item)"
                    :class="{'active': currentHeroIndex === index}"
                    :style="`background-image: url(${getItemImage(item)})`"
                    @click="playHeroItem(item)">
                    <div class="hero-overlay">
                        <div class="hero-content">
                            <div class="hero-badge ahoy-subheader" x-text="getPageBadge()"></div>
                            <h1 x-text="getItemTitle(item)"></h1>
                            <p x-text="getItemSubtitle(item)"></p>
                            <button @click.stop="playHeroItem(item)" class="hero-play-btn">
                                <i class="fas fa-play"></i>
                            </button>
                        </div>
                    </div>
                </div>
            </template>
        </div>
        <div class="hero-controls">
            <button @click="prevHero()" class="hero-nav">
                <i class="fas fa-chevron-left"></i>
            </button>
            <button @click="nextHero()" class="hero-nav">
                <i class="fas fa-chevron-right"></i>
            </button>
        </div>
        <div class="hero-indicators">
            <template x-for="(item, index) in heroItems" :key="item.id">
                <button @click="setHeroIndex(index)" :class="{'active': currentHeroIndex === index}" class="hero-dot"></button>
            </template>
        </div>
    </section>
    <!-- Unified Header Section -->
    <section class="unified-header music-subheader">
        <div class="header-content">
            <div class="header-title">
                <div class="title-text">
                    <h1>Music Library</h1>
                    <p>Discover tracks, albums, and artists</p>
                    <div class="header-stats" x-show="bookmarkCount() > 0">
                        <a href="/my-saves" class="bookmark-count-badge">
                            <i class="fas fa-bookmark"></i>
                            <span x-text="bookmarkCount()"></span>
                            <span x-text="bookmarkCount() === 1 ? 'saved' : 'saved'"></span>
                        </a>
                    </div>
                </div>
            </div>

            <div class="header-search desktop-only">
                <div class="search-bar">
                    <i class="fas fa-search"></i>
                    <input type="text"
                        x-model="searchQuery"
                        @input="filterMusic()"
                        placeholder="Search music, artists, or genres..."
                        class="search-input">
                    <button @click="clearSearch()" class="search-clear"
                        x-show="searchQuery">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
            </div>

            <div class="header-filters">
                <div class="filter-group">
                    <label>Artist:</label>
                    <select x-model="selectedArtist" @change="filterMusic()">
                        <option value>All Artists</option>
                        <template x-for="artist in artists" :key="artist">
                            <option :value="artist" x-text="artist"></option>
                        </template>
                    </select>
                </div>

                <div class="filter-group">
                    <label>Sort by:</label>
                    <select x-model="sortBy" @change="sortMusic()">
                        <option value="title">Title</option>
                        <option value="artist">Artist</option>
                        <option value="plays">Plays</option>
                        <option value="added_date">Date Added</option>
                    </select>
                </div>
            </div>

            <div class="header-actions">
                <div class="view-options">
                    <button @click="viewMode = 'grid'"
                        :class="{'active': viewMode === 'grid'}"
                        class="view-btn">
                        <i class="fas fa-th"></i>
                    </button>
                    <button @click="viewMode = 'list'"
                        :class="{'active': viewMode === 'list'}"
                        class="view-btn">
                        <i class="fas fa-list"></i>
                    </button>
                </div>
                <button @click="playRandomTrack()"
                    class="btn btn-primary btn-large">
                    <i class="fas fa-play"></i> Play Random
                </button>
            </div>
        </div>
    </section>

    <!-- Music Grid View -->
    <div x-show="viewMode === 'grid'" class="music-grid">
        <template x-for="track in filteredTracks" :key="track.id">
            <div class="track-card"
                @click="playTrack(track)"
                :class="{'playing': currentTrack?.id === track.id}">

                <div class="track-cover">
                    <img
                        :src="track.cover_art || '/static/img/default-cover.jpg'"
                        :alt="track.title"
                        class="image-placeholder"
                        loading="lazy"
                        @error="handleImageError($event, track)">
                    <div class="track-overlay">
                        <button @click.stop="playTrack(track)" class="play-btn">
                            <i class="fas fa-play"></i>
                        </button>
                        <div class="track-actions">
                            <button class="action-btn save-btn bm-btn"
                                @click.stop="toggleBookmark({ type: 'track', id: track.id, title: track.title, artwork: track.cover_art }); $el.classList.add('sparkle'); setTimeout(() => $el.classList.remove('sparkle'), 600)"
                                :aria-pressed="isBookmarked('track', track.id)"
                                :class="{ 'bookmarked': isBookmarked('track', track.id), 'just-bookmarked': isBookmarked('track', track.id) }">
                                    <span aria-hidden="true">
                                        <i x-show="isBookmarked('track', track.id)" class="fas fa-bookmark" style="color: var(--accent-color);"></i>
                                        <i x-show="!isBookmarked('track', track.id)" class="far fa-bookmark"></i>
                                    </span>
                                <span class="sr-only" x-text="isBookmarked('track', track.id) ? 'Remove bookmark' : 'Add bookmark'"></span>
                            </button>
                        </div>
                    </div>
                </div>

                <div class="track-info">
                    <h4 x-text="track.title"></h4>
                    <p x-text="track.artist"></p>
                    <div class="track-meta">
                    </div>
                </div>
            </div>
        </template>
    </div>

    <!-- Music List View -->
    <div x-show="viewMode === 'list'" class="music-list">
        <div class="music-table-wrap">
            <table class="music-table">
                <thead>
                    <tr>
                        <th class="col-play"></th>
                        <th class="col-title">Title</th>
                        <th class="col-artist">Artist</th>
                        <th class="col-plays" @click="sortByPlays()">
                            Plays <i class="fas fa-sort-down" x-show="sortBy === 'plays'"></i>
                        </th>
                        <th class="col-action">Action</th>
                    </tr>
                </thead>
                <tbody>
                    <template x-for="(track, index) in filteredTracks" :key="track.id">
                        <tr class="music-table-row"
                            @click="playTrack(track)"
                            :class="{'playing': currentTrack?.id === track.id}">
                            <td class="col-play" data-label="">
                                <button class="play-btn" 
                                    @click.stop="playTrack(track)" 
                                    :aria-label="(currentTrack?.id === track.id && isPlaying) ? 'Pause ' + track.title : 'Play ' + track.title">
                                    <i x-show="currentTrack?.id === track.id && isPlaying" class="fas fa-pause"></i>
                                    <i x-show="!(currentTrack?.id === track.id && isPlaying)" class="fas fa-play"></i>
                                </button>
                            </td>
                            <td class="col-title" data-label="Title">
                                <span class="title-text" x-text="track.title"></span>
                            </td>
                            <td class="col-artist" data-label="Artist" x-text="track.artist"></td>
                            <td class="col-plays" data-label="Plays" x-text="track.play_count || 0"></td>
                            <td class="col-action" data-label="Action">
                                <button class="action-btn bm-btn"
                                    @click.stop="toggleBookmark({ type: 'track', id: track.id, title: track.title, artwork: track.cover_art })"
                                    :aria-pressed="isBookmarked('track', track.id)"
                                    :class="{ 'bookmarked': isBookmarked('track', track.id) }"
                                    :aria-label="isBookmarked('track', track.id) ? 'Remove bookmark' : 'Add bookmark'">
                                    <i x-show="isBookmarked('track', track.id)" class="fas fa-bookmark"></i>
                                    <i x-show="!isBookmarked('track', track.id)" class="far fa-bookmark"></i>
                                </button>
                            </td>
                        </tr>
                    </template>
                </tbody>
            </table>
        </div>
    </div>

    <!-- Loading State -->
    <div x-show="isLoading" class="loading-state">
        <div class="spinner"></div>
        <p>Loading music library...</p>
    </div>

    <!-- Empty State -->
    <div x-show="!isLoading && filteredTracks.length === 0" class="empty-state">
        <i class="fas fa-music"></i>
        <h3>No music found</h3>
        <p>Try adjusting your filters or search terms</p>
    </div>

    <!-- Add to Board Modal -->
    <div x-show="showAddToBoardModal" class="modal-overlay"
        @click="showAddToBoardModal = false">
        <div class="modal-content" @click.stop>
            <div class="modal-header">
                <h3>Add to Board</h3>
                <button @click="showAddToBoardModal = false" class="close-btn">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="modal-body">
                <div class="playlist-list">
                    <template x-for="playlist in playlists" :key="playlist.id">
                        <div class="playlist-option"
                            @click="addToBoard(playlist)">
                            <div class="playlist-color"
                                :style="`background-color: ${playlist.color}`"></div>
                            <div class="playlist-info">
                                <h4 x-text="playlist.name"></h4>
                                <p x-text="playlist.total_items + ' items'"></p>
                            </div>
                            <button class="add-btn">
                                <i class="fas fa-plus"></i>
                            </button>
                        </div>
                    </template>

                    <div class="create-playlist-option"
                        @click="showCreateBoardModal = true">
                        <div class="playlist-color"
                            style="background: linear-gradient(45deg, #6366f1, #8b5cf6);"></div>
                        <div class="playlist-info">
                            <h4>Create New Board</h4>
                            <p>Start a new collection</p>
                        </div>
                        <button class="add-btn">
                            <i class="fas fa-plus"></i>
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Create Board Modal -->
    <div x-show="showCreateBoardModal" class="modal-overlay"
        @click="showCreateBoardModal = false">
        <div class="modal-content" @click.stop>
            <div class="modal-header">
                <h3>Create New Board</h3>
                <button @click="showCreateBoardModal = false" class="close-btn">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label>Board Name</label>
                    <input type="text" x-model="newBoard.name"
                        placeholder="Enter playlist name">
                </div>
                <div class="form-group">
                    <label>Description</label>
                    <textarea x-model="newBoard.description"
                        placeholder="Enter playlist description"></textarea>
                </div>
                <div class="form-group">
                    <label>Color</label>
                    <div class="color-picker">
                        <button @click="newBoard.color = '#6366f1'"
                            :class="{'active': newBoard.color === '#6366f1'}"
                            class="color-option"
                            style="background: #6366f1;"></button>
                        <button @click="newBoard.color = '#ef4444'"
                            :class="{'active': newBoard.color === '#ef4444'}"
                            class="color-option"
                            style="background: #ef4444;"></button>
                        <button @click="newBoard.color = '#10b981'"
                            :class="{'active': newBoard.color === '#10b981'}"
                            class="color-option"
                            style="background: #10b981;"></button>
                        <button @click="newBoard.color = '#f59e0b'"
                            :class="{'active': newBoard.color === '#f59e0b'}"
                            class="color-option"
                            style="background: #f59e0b;"></button>
                        <button @click="newBoard.color = '#8b5cf6'"
                            :class="{'active': newBoard.color === '#8b5cf6'}"
                            class="color-option"
                            style="background: #8b5cf6;"></button>
                        <button @click="newBoard.color = '#ec4899'"
                            :class="{'active': newBoard.color === '#ec4899'}"
                            class="color-option"
                            style="background: #ec4899;"></button>
                    </div>
                </div>
                <div class="form-group">
                    <label>
                        <input type="checkbox" x-model="newBoard.is_public">
                        Make this playlist public
                    </label>
                </div>
            </div>
            <div class="modal-footer">
                <button @click="showCreateBoardModal = false"
                    class="btn btn-outline">Cancel</button>
                <button @click="createBoard()" class="btn btn-primary">Create
                    Board</button>
            </div>
        </div>
    </div>
</div>

<script>
function musicLibrary() {
    return {
        // State
        tracks: [],
        filteredTracks: [],
        artists: [],
        artistCoverMap: {},
        viewMode: 'grid',
        searchQuery: '',
        selectedArtist: '',
        sortBy: 'plays',
        isLoading: true,
        currentTrack: null,
        isPlaying: false,
        showAddToBoardModal: false,
        showCreateBoardModal: false,
        selectedTrack: null,
        playlists: [],
        newBoard: {
            name: '',
            description: '',
            color: '#6366f1',
            is_public: false
        },
        
        // Initialize
        async loadMusic() {
            // Listen to player events
            if (window.mediaPlayer) {
                window.mediaPlayer.on('play', () => {
                    this.isPlaying = true;
                });
                window.mediaPlayer.on('pause', () => {
                    this.isPlaying = false;
                });
                window.mediaPlayer.on('trackchange', (track) => {
                    this.currentTrack = track;
                    this.isPlaying = true;
                });
            }
            
            // Also listen to custom events
            document.addEventListener('play-track', (e) => {
                this.currentTrack = e.detail.track;
            });
            
            document.addEventListener('ahoy:player:play', () => {
                this.isPlaying = true;
            });
            
            document.addEventListener('ahoy:player:pause', () => {
                this.isPlaying = false;
            });
            
            try {
                this.isLoading = true;
                const response = await fetch('/api/music');
                const data = await response.json();
                this.tracks = data.tracks || [];
                this.filteredTracks = [...this.tracks];
                this.extractArtists();
                this.buildArtistCoverMap();
                this.sortMusic();
            } catch (error) {
                console.error('Error loading music:', error);
            } finally {
                this.isLoading = false;
            }
        },
        
        extractArtists() {
            const artistSet = new Set();

            this.tracks.forEach(track => {
                if (track.artist) artistSet.add(track.artist);
            });

            this.artists = Array.from(artistSet).sort();
        },

        // Build a map of artist -> array of valid cover URLs for fallback
        buildArtistCoverMap() {
            this.artistCoverMap = {};
            this.tracks.forEach(track => {
                if (track.artist && track.cover_art) {
                    if (!this.artistCoverMap[track.artist]) {
                        this.artistCoverMap[track.artist] = [];
                    }
                    // Avoid duplicates
                    if (!this.artistCoverMap[track.artist].includes(track.cover_art)) {
                        this.artistCoverMap[track.artist].push(track.cover_art);
                    }
                }
            });
        },

        // Handle image load errors - try another cover from same artist
        handleImageError(event, track) {
            const img = event.target;
            const failedSrc = img.src;

            // Mark this URL as failed
            if (!this._failedImages) this._failedImages = new Set();
            this._failedImages.add(failedSrc);

            // Try to find another cover from the same artist
            const artistCovers = this.artistCoverMap[track.artist] || [];
            const validCover = artistCovers.find(url => !this._failedImages.has(url));

            if (validCover) {
                img.src = validCover;
                // Also update the track object so bookmarks get the right image
                track.cover_art = validCover;
            } else {
                // All artist covers failed, use default
                img.src = '/static/img/default-cover.jpg';
            }
        },

        // Filtering and sorting
        filterMusic() {
            let filtered = [...this.tracks];
            
            // Search filter
            if (this.searchQuery) {
                const query = this.searchQuery.toLowerCase();
                filtered = filtered.filter(track => 
                    track.title.toLowerCase().includes(query) ||
                    track.artist.toLowerCase().includes(query) ||
                    track.album?.toLowerCase().includes(query)
                );
            }
            
            // Artist filter
            if (this.selectedArtist) {
                filtered = filtered.filter(track => track.artist === this.selectedArtist);
            }
            
            this.filteredTracks = filtered;
            this.sortMusic();
        },
        
        sortMusic() {
            this.filteredTracks.sort((a, b) => {
                switch (this.sortBy) {
                    case 'title':
                        return a.title.localeCompare(b.title);
                    case 'artist':
                        return a.artist.localeCompare(b.artist);
                    case 'added_date':
                        return new Date(b.added_date || 0) - new Date(a.added_date || 0);
                    case 'plays':
                        return (b.play_count || 0) - (a.play_count || 0);
                    default:
                        return 0;
                }
            });
        },
        
        sortByPlays() {
            if (this.sortBy === 'plays') {
                // Toggle ascending/descending if already sorted by plays
                this.filteredTracks.reverse();
            } else {
                this.sortBy = 'plays';
                this.sortMusic();
            }
        },
        
        // Track actions
        playTrack(track) {
            // Prevent multiple rapid calls
            if (this._playTrackDebounce) {
                clearTimeout(this._playTrackDebounce);
            }
            
            this._playTrackDebounce = setTimeout(() => {
                // If same track is playing, toggle pause
                if (this.currentTrack?.id === track.id && this.isPlaying) {
                    this.togglePlayPause();
                    return;
                }
                
                this.currentTrack = track;
                
                // Dispatch custom event to trigger global player
                document.dispatchEvent(new CustomEvent('play-track', {
                    detail: { 
                        track: track,
                        type: 'track'
                    }
                }));
            }, 100);
        },
        
        togglePlayPause() {
            if (!window.mediaPlayer) return;
            
            if (this.isPlaying) {
                window.mediaPlayer.pause();
                this.isPlaying = false;
            } else {
                if (this.currentTrack) {
                    window.mediaPlayer.play(this.currentTrack);
                    this.isPlaying = true;
                } else if (window.mediaPlayer.currentTrack) {
                    window.mediaPlayer.resume();
                    this.isPlaying = true;
                }
            }
        },

        playRandomTrack() {
            if (this.filteredTracks.length > 0) {
                const randomIndex = Math.floor(Math.random() * this.filteredTracks.length);
                this.playTrack(this.filteredTracks[randomIndex]);
            }
        },


        async saveTrack(track) {
            try {
                console.log('Bookmarking track:', track);
                const isCurrentlySaved = this.isSaved(track);
                console.log('Currently saved:', isCurrentlySaved);
                
                // Use the unified bookmarks system
                if (window.AhoyBookmarks) {
                    const item = {
                        type: 'track',
                        id: track.id,
                        title: track.title,
                        artwork: track.cover_art
                    };
                    window.AhoyBookmarks.toggle(item);
                    track.saved = !isCurrentlySaved;
                    this.showNotification(!isCurrentlySaved ? 'Bookmarked track!' : 'Removed from bookmarks', 'success');
                } else {
                    // Fallback to API
                    const response = await fetch('/api/bookmarks', {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({
                            media_id: String(track.id),
                            media_type: 'music'
                        })
                    });
                    
                    if (response.ok) {
                        const result = await response.json();
                        track.saved = result.persisted !== false;
                        this.showNotification('Bookmarked track!', 'success');
                    } else {
                        console.error('Bookmark failed');
                        this.showNotification('Failed to bookmark track', 'error');
                    }
                }
            } catch (error) {
                console.error('Error bookmarking track:', error);
                this.showNotification('Failed to bookmark track: ' + error.message, 'error');
            }
        },
        
        addToPlaylist(track) {
            // Show add to playlist modal
            this.selectedTrack = track;
            this.showAddToPlaylistModal = true;
        },
        
        showAddToPlaylist(track) {
            this.selectedTrack = track;
            this.loadPlaylists();
            this.showAddToPlaylistModal = true;
        },
        
        async loadPlaylists() {
            try {
                const response = await fetch('/api/playlists');
                const data = await response.json();
                this.playlists = data.playlists || [];
            } catch (error) {
                console.error('Error loading playlists:', error);
            }
        },
        
        async addToPlaylist(playlist) {
            if (!this.selectedTrack) return;
            
            try {
                const response = await fetch(`/api/playlists/${playlist.id}/add`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        type: 'track',
                        id: this.selectedTrack.id,
                        data: this.selectedTrack
                    })
                });
                
                const result = await response.json();
                
                if (response.ok) {
                    this.showAddToBoardModal = false;
                    this.selectedTrack = null;
                    
                    if (result.guest) {
                        this.showNotification('Added to playlist! (Guest mode - create account to keep permanently)', 'info');
                        this.showUpgradePrompt();
                    } else {
                        this.showNotification('Added to playlist!', 'success');
                    }
                } else {
                    this.showNotification(result.error || 'Failed to add to playlist', 'error');
                }
            } catch (error) {
                console.error('Error adding to playlist:', error);
                this.showNotification('Failed to add to playlist', 'error');
            }
        },
        
        async createBoard() {
            try {
                const response = await fetch('/api/playlists', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify(this.newBoard)
                });
                
                if (response.ok) {
                    const data = await response.json();
                    this.playlists.push(data.playlist);
                    this.showCreateBoardModal = false;
                    this.newBoard = { name: '', description: '', color: '#6366f1', is_public: false };
                    this.showNotification('Board created!', 'success');
                }
            } catch (error) {
                console.error('Error creating playlist:', error);
                this.showNotification('Failed to create playlist', 'error');
            }
        },
        
        showNotification(message, type = 'info') {
            // Simple notification system
            const notification = document.createElement('div');
            notification.className = `notification notification-${type}`;
            notification.textContent = message;
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                padding: 12px 20px;
                background: ${type === 'success' ? '#10b981' : type === 'error' ? '#ef4444' : '#6366f1'};
                color: white;
                border-radius: 8px;
                z-index: 1000;
                font-weight: 500;
            `;
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.remove();
            }, 3000);
        },
        
        showUpgradePrompt() {
            // Show upgrade prompt for guest users
            const prompt = document.createElement('div');
            prompt.className = 'upgrade-prompt';
            prompt.innerHTML = `
                <div class="upgrade-content">
                    <div class="upgrade-icon">ðŸŽµ</div>
                    <h3>Keep Your Music Forever!</h3>
                    <p>You're saving content as a guest. Create a free account to keep your playlists and saves permanently.</p>
                    <div class="upgrade-actions">
                        <button onclick="window.location.href='/register'" class="btn btn-primary">Create Account</button>
                        <button onclick="this.closest('.upgrade-prompt').remove()" class="btn btn-outline">Maybe Later</button>
                    </div>
                </div>
            `;
            prompt.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: var(--background-light);
                border-radius: 12px;
                padding: 24px;
                box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
                z-index: 1001;
                max-width: 400px;
                text-align: center;
            `;
            document.body.appendChild(prompt);
            
            // Auto-remove after 10 seconds
            setTimeout(() => {
                if (prompt.parentNode) {
                    prompt.remove();
                }
            }, 10000);
        },
        
        async migrateGuestData() {
            try {
                // Get guest data
                const guestResponse = await fetch('/api/guest-data');
                const guestData = await guestResponse.json();
                
                if (guestData.error) {
                    this.showNotification('No guest data to migrate', 'info');
                    return;
                }
                
                // Migrate to user account
                const migrateResponse = await fetch('/api/migrate-guest-data', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify(guestData)
                });
                
                const result = await migrateResponse.json();
                
                if (migrateResponse.ok) {
                    this.showNotification(result.message, 'success');
                    // Reload playlists
                    this.loadBoards();
                } else {
                    this.showNotification('Failed to migrate data', 'error');
                }
            } catch (error) {
                console.error('Error migrating guest data:', error);
                this.showNotification('Failed to migrate data', 'error');
            }
        },
        
        showTrackMenu(track) {
            // Show track context menu
            console.log('Showing track menu:', track);
        },
        
        isSaved(track) {
            // Check server state first
            if (track.saved !== undefined) {
                return track.saved;
            }
            
            // Check local storage
            const key = `track:${track.id}`;
            const localBookmarks = JSON.parse(localStorage.getItem('ahoy_bookmarks') || '[]');
            return localBookmarks.includes(key);
        },
        
        // Bookmark methods
        toggleBookmark(item) {
            if (window.AhoyBookmarks) {
                window.AhoyBookmarks.toggle(item);
                // Force Alpine.js to re-evaluate bookmark states
                this.$nextTick(() => {
                    // Trigger reactivity by updating a dummy property
                    this.lastBookmarkAction = Date.now();
                });
            }
        },
        
        isBookmarked(type, id) {
            // Access lastBookmarkAction to trigger reactivity
            this.lastBookmarkAction;
            if (window.AhoyBookmarks) {
                return window.AhoyBookmarks.isBookmarked(type, id);
            }
            return false;
        },
        
        lastBookmarkAction: 0,
        
        bookmarkCount() {
            // Access lastBookmarkAction to trigger reactivity
            this.lastBookmarkAction;
            if (window.AhoyBookmarks) {
                return window.AhoyBookmarks.all().length;
            }
            return 0;
        },
        
        // Utility functions
        formatTime(seconds) {
            if (!seconds || seconds === 0) return '--:--';
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }
    };
}

</script>
{% endblock %}

{% block extra_head %}
<script src="{{ url_for('static', filename='js/unified-hero.js') }}"></script>
<style>
</style>
{% endblock %}
